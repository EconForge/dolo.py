{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dolo Introduction Dolo is a tool to describe and solve economic models. It provides a simple classification scheme to describe many types of models, allows to write the models as simple text files and compiles these files into efficient Python objects representing them. It also provides many reference solution algorithms to find the solution of these models under rational expectations. Dolo understand several types of nonlinear models with occasionnally binding constraints (with or without exogenous discrete shocks), as well as local pertubations models, like Dynare. It is a very adequate tool to study zero-lower bound issues, or sudden-stop problems, for instance. Sophisticated solution routines are available: local perturbations up to third order, perfect foresight solution, policy iteration, value iteration. Most of these solutions are either parallelized or vectorized. They are written in pure Python, and can easily be inspected or adapted. Thanks to the simple and consistent Python API for models, it is possible to write models in pure Python, or to implement other solution algorithms on top it. Frequently Asked Questions No question was ever asked. Certainly because it's all very clear.","title":"Home"},{"location":"#dolo","text":"","title":"Dolo"},{"location":"#introduction","text":"Dolo is a tool to describe and solve economic models. It provides a simple classification scheme to describe many types of models, allows to write the models as simple text files and compiles these files into efficient Python objects representing them. It also provides many reference solution algorithms to find the solution of these models under rational expectations. Dolo understand several types of nonlinear models with occasionnally binding constraints (with or without exogenous discrete shocks), as well as local pertubations models, like Dynare. It is a very adequate tool to study zero-lower bound issues, or sudden-stop problems, for instance. Sophisticated solution routines are available: local perturbations up to third order, perfect foresight solution, policy iteration, value iteration. Most of these solutions are either parallelized or vectorized. They are written in pure Python, and can easily be inspected or adapted. Thanks to the simple and consistent Python API for models, it is possible to write models in pure Python, or to implement other solution algorithms on top it.","title":"Introduction"},{"location":"#frequently-asked-questions","text":"No question was ever asked. Certainly because it's all very clear.","title":"Frequently Asked Questions"},{"location":"finite_iteration/","text":"Finite iteration By default, dolo looks for solutions, where the time horizon of the optimizing agent is infinite. But it is possible to use it to solve finite horizon problems (only with time-iteration, so far). It requires to do two things: Construct a final decision rule to be used for the last period. This can be done with the CustomDR function. ResultingsIt is passed as an initial guess to time_iteration . Record the decision rules, obtained in each iteration. Example from dolo import yaml_import, time_iteration, tabulate from dolo.numeric.decision_rule import CustomDR model = yaml_import(\"examples/models/consumption_savings.yaml\") last_dr = CustomDR( {\"c\": \"w\"}, model=model ) T = 10 result = time_iteration(model, dr0=last_dr, maxit=T, trace=True # keeps decision rules, from all iterations ) # example to plot all decision rules from matplotlib import pyplot as plt for i,tr in enumerate(result.trace): dr = tr['dr'] tab = tabulate(model, dr, 'w') plt.plot(tab['w'], tab['c'], label=f\"t={T-i}\") plt.legend(loc='upper left') plt.show() In the example above, {\"c\": \"w\"} stands for a functional identity, i.e. c(y,w) = w. It is a completely different meaning from c: w in the calibration section which means that the steady-state value of c is initialized to the steady-state value of w . Alert The notation in CustomDR is not yet consistent, with the new timing conventions. In the example above it should be c[t] = w[t] . A commission, will be created to examine the creation of an issue, meant to coordinate the implementation of a solution.","title":"Finite Horizon Time Iteration"},{"location":"finite_iteration/#finite-iteration","text":"By default, dolo looks for solutions, where the time horizon of the optimizing agent is infinite. But it is possible to use it to solve finite horizon problems (only with time-iteration, so far). It requires to do two things: Construct a final decision rule to be used for the last period. This can be done with the CustomDR function. ResultingsIt is passed as an initial guess to time_iteration . Record the decision rules, obtained in each iteration. Example from dolo import yaml_import, time_iteration, tabulate from dolo.numeric.decision_rule import CustomDR model = yaml_import(\"examples/models/consumption_savings.yaml\") last_dr = CustomDR( {\"c\": \"w\"}, model=model ) T = 10 result = time_iteration(model, dr0=last_dr, maxit=T, trace=True # keeps decision rules, from all iterations ) # example to plot all decision rules from matplotlib import pyplot as plt for i,tr in enumerate(result.trace): dr = tr['dr'] tab = tabulate(model, dr, 'w') plt.plot(tab['w'], tab['c'], label=f\"t={T-i}\") plt.legend(loc='upper left') plt.show() In the example above, {\"c\": \"w\"} stands for a functional identity, i.e. c(y,w) = w. It is a completely different meaning from c: w in the calibration section which means that the steady-state value of c is initialized to the steady-state value of w . Alert The notation in CustomDR is not yet consistent, with the new timing conventions. In the example above it should be c[t] = w[t] . A commission, will be created to examine the creation of an issue, meant to coordinate the implementation of a solution.","title":"Finite iteration"},{"location":"inspect/","text":"Inspecting the solution The output of most solution methods is a decision rule for the controls as a function of the exogenous and endogenous states: dr . This decision rule can be called using one of the following methods: dr.eval_s(s: array) : function of endogenous state. Works only if exgogenous process is i.i.d. dr.eval_ms(m: array,s: array) : function of exogenous and endogenous values. Works only if exogenous process is continuous. dr.eval_is(i: int,s: array) : function of exognous index and endogenous values. Works only if some indexed discrete values are associated with exogenous process. There is also a __call__ function, which tries to make the sensible call based on argument types. Hence dr(0, s) will behave as the third example. Tabulating a decision rule Dolo provides a convenience function to plot the values of a decision rule against different values of a state: function dolo.algos.simulations. tabulate ( model , dr , state , bounds=None , n_steps=100 , s0=None , i0=None , m0=None , **kwargs ) Stochastic simulations Given a model object and a corresponding decision rule, one can get a N stochastic simulation for T periods, using the simulate function. The resulting object is an 3-dimensional DataArray , with the following labelled axes: T: date of the simulation ( range(0,T) ) N: index of the simulation ( range(0,N) ) V: variables of the model ( model.variables ) function dolo.algos.simulations. simulate ( model , dr , process=None , N=1 , T=40 , s0=None , i0=None , m0=None , driving_process=None , seed=42 , stochastic=True ) Simulate a model using the specified decision rule. Returns (xarray.DataArray:) returns a T x N x n_v array where n_v is the number of variables. Impulse response functions For continuously valued exogenous shocks, one can perform an impulse response function: function dolo.algos.simulations. response ( model , dr , varname , T=40 , impulse=None ) Graphing nonstochastic simulations Given one or many nonstochstic simulations of a model, obtained with response , or deterministic_solve it is possible to quickly create an irf for multiple variables. function dolo.misc.graphs. plot_irfs ( sims , variables=None , titles=None , layout=None , horizon=None , figsize=None , plot_options={} , line_options=None )","title":"Inspecting the Solution"},{"location":"inspect/#inspecting-the-solution","text":"The output of most solution methods is a decision rule for the controls as a function of the exogenous and endogenous states: dr . This decision rule can be called using one of the following methods: dr.eval_s(s: array) : function of endogenous state. Works only if exgogenous process is i.i.d. dr.eval_ms(m: array,s: array) : function of exogenous and endogenous values. Works only if exogenous process is continuous. dr.eval_is(i: int,s: array) : function of exognous index and endogenous values. Works only if some indexed discrete values are associated with exogenous process. There is also a __call__ function, which tries to make the sensible call based on argument types. Hence dr(0, s) will behave as the third example.","title":"Inspecting the solution"},{"location":"inspect/#tabulating-a-decision-rule","text":"Dolo provides a convenience function to plot the values of a decision rule against different values of a state: function dolo.algos.simulations. tabulate ( model , dr , state , bounds=None , n_steps=100 , s0=None , i0=None , m0=None , **kwargs )","title":"Tabulating a decision rule"},{"location":"inspect/#stochastic-simulations","text":"Given a model object and a corresponding decision rule, one can get a N stochastic simulation for T periods, using the simulate function. The resulting object is an 3-dimensional DataArray , with the following labelled axes: T: date of the simulation ( range(0,T) ) N: index of the simulation ( range(0,N) ) V: variables of the model ( model.variables ) function dolo.algos.simulations. simulate ( model , dr , process=None , N=1 , T=40 , s0=None , i0=None , m0=None , driving_process=None , seed=42 , stochastic=True ) Simulate a model using the specified decision rule. Returns (xarray.DataArray:) returns a T x N x n_v array where n_v is the number of variables.","title":"Stochastic simulations"},{"location":"inspect/#impulse-response-functions","text":"For continuously valued exogenous shocks, one can perform an impulse response function: function dolo.algos.simulations. response ( model , dr , varname , T=40 , impulse=None )","title":"Impulse response functions"},{"location":"inspect/#graphing-nonstochastic-simulations","text":"Given one or many nonstochstic simulations of a model, obtained with response , or deterministic_solve it is possible to quickly create an irf for multiple variables. function dolo.misc.graphs. plot_irfs ( sims , variables=None , titles=None , layout=None , horizon=None , figsize=None , plot_options={} , line_options=None )","title":"Graphing nonstochastic simulations"},{"location":"installation/","text":"Basic installation Dolo can be installed in several ways: with anaconda (recommended): conda install -c conda-forge dolo with pip pip install dolo Developper's installation Dolo uses poetry as package manager, so you probably need to install poetry before you start developing the package.","title":"Install"},{"location":"installation/#basic-installation","text":"Dolo can be installed in several ways: with anaconda (recommended): conda install -c conda-forge dolo with pip pip install dolo","title":"Basic installation"},{"location":"installation/#developpers-installation","text":"Dolo uses poetry as package manager, so you probably need to install poetry before you start developing the package.","title":"Developper's installation"},{"location":"model_api/","text":"Model API For numerical purposes, models are essentially represented as a set of symbols, calibration and functions representing the various equation types of the model. This data is held in a Model object whose API is described in this chapter. Models are usually created by writing a Yaml files as described in the the previous chapter, but as we will see below, they can also be written directly as long as they satisfy the requirements detailed below. Model Object As previously, let's consider, the Real Business Cycle example, from the introduction. The model object can be created using the yaml file: model = yaml_import('models/rbc.yaml') The object contains few meta-data: display( model.name ) # -> \"Real Business Cycles\" display( model.infos ) # -> {\"name\": \"Real Business Cycle\", \"filename\": \"examples/models/rbc.yaml\", \"type\": \"dtcc\"} Calibration Each models stores calibration information as model.calibration . It is a special dictionary-like object, which contains calibration information, that is values for parameters and initial values (or steady-state) for all other variables of the model. It is possible to retrieve one or several variables calibrations: display( model.calibration['k'] ) # -> 2.9 display( model.calibration['k', 'delta'] # -> [2.9, 0.08] When a key coresponds to one of the symbols group, one gets one or several vectors of variables instead: model.calibration['states'] # - > np.array([2.9, 0]) (values of states [z, k]) model.calibration['states', 'controls'] # -> [np.array([2.9, 0]), np.array([0.29, 1.0])] To get regular dictionary mapping states groups and vectors, one can use the attributed .grouped The values are vectors (1d numpy arrays) of values for each symbol group. For instance the following code will print the calibrated values of the parameters: for (variable_group, variables) in model.calibration.items(): print(variables_group, variables) In order to get a (key,values) of all the values of the model, one can call model.calibration.flat . for (variable_group, variables) in model.calibration.items(): print(variables_group, variables) Note The calibration object can contain values that are not symbols of the model. These values can be used to calibrate model parameters and are also evaluated in the other yaml sections, using the supplied value. One uses the model.set_calibration() routine to change the calibration of the model. This one takes either a dict as an argument, or a set of keyword arguments. Both calls are valid: model.set_calibration( {'delta':0.01} ) model.set_calibration( {'i': 'delta*k'} ) model.set_calibration( delta=0.08, k=2.8 ) This method also understands symbolic expressions (as string) which makes it possible to define symbols as a function of other symbols: model.set_calibration(beta='1/(1+delta)') print(model.get_calibration('beta')) # -> nan model.set_calibration(delta=0.04) print(model.get_calibration(['beta', 'delta'])) # -> [0.96, 0.04] Under the hood, the method stores the symbolic relations between symbols. It is precisely equivalent to use the set_calibration method or to change the values in the yaml files. In particular, the calibration order is irrelevant as long as all parameters can be deduced one from another. Functions A model of a specific type can feature various kinds of functions. For instance, a continuous-states-continuous-controls models, solved by iterating on the Euler equations may feature a transition equation g g and an arbitrage equation f f . Their signature is respectively s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) and E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] , where s_t s_t , x_t x_t and m_t m_t respectively represent a vector of states, controls and exogenous shock. Implicitly, all functions are also assumed to depend on the vector of parameters p p . These functions can be accessed by their type in the model.functions dictionary: g = model.functions['transition'] f = model.functions['arbitrage'] Let's call the arbitrage function on the steady-state value, to see the residuals at the deterministic steady-state: m = model.calibration[\"exogenous\"] s = model.calibration[\"states\"] x = model.calibration[\"controls\"] p = model.calibration[\"parameters\"] res = f(m,s,x,m,s,x,p) display(res) The output ( res ) is two element vector, representing the residuals of the two arbitrage equations at the steady-state. It should be full of zero. Is it ? Great ! By inspecting the arbitrage function ( f? ), one can see that its call api is: f(m,s,x,M,S,X,p,diff=False,out=None) Since m , s and x are the short names for exogenous shocks, states and controls, their values at date t+1 t+1 is denoted with S and X . This simple convention prevails in most of dolo source code: when possible, vectors at date t are denoted with lowercase, while future vectors are with upper case. We have already commented the presence of the parameter vector p . Now, the generated functions also gives the option to perform in place computations, when an output vector is given: out = numpy.ones(2) f(m,s,x,m,s,x,p,out) # out now contains zeros It is also possible to compute derivatives of the function by setting diff=True . In that case, the residual and jacobians with respect to the various arguments are returned as a list: r, r_m, r_s, r_x, r_M, r_S, r_X = f(m,s,x,m,s,x,p,diff=True) Since there are two states and two controls, the variables r_s, r_x, r_S, r_X are all 2 by 2 matrices. The generated functions also allow for efficient vectorized evaluation. In order to evaluate the residuals :math: N times, one needs to supply matrix arguments, instead of vectors, so that each line corresponds to one value to evaluate as in the following example: N = 10000 vec_m = m[None,:].repeat(N, axis=0) # we repeat each line N times vec_s = s[None,:].repeat(N, axis=0) # we repeat each line N times vec_x = x[None,:].repeat(N, axis=0) vec_X = X[None,:].repeat(N, axis=0) vec_p = p[None,:].repeat(N, axis=0) # actually, except for vec_s, the function repeat is not need since broadcast rules apply vec_s[:,0] = linspace(2,4,N) # we provide various guesses for the steady-state capital vec_S = vec_s out = f(vec_m, vec_s,vec_x,vec_M, vec_S,vec_X,vec_p) # now a 10000 x 2 array out, out_m, out_s, out_x, out_M, out_S, out_X = f(vec_m, vec_s,vec_x, vec_m, vec_S,vec_X,vec_p) The vectorized evaluation is optimized so that it is much faster to make a vectorized call rather than iterate on each point. Note In the preceding example, the parameters are constant for all evaluations, yet they are repeated. This is not mandatory, and the call f(vec_m, vec_s, vec_x, vec_M, vec_S, vec_X, p) should work exactly as if p had been repeated along the first axis. We follow there numba's guvectorize conventions, even though they slightly differ from numpy's ones. Exogenous shock The exogenous field contains information about the driving process. To get its default, discretized version, one can call model.exogenous.discretize() . Options structure The model.options structure holds an information required by a particular solution method. For instance, for global methods, model.options['grid'] is supposed to hold the boundaries and the number nodes at which to interpolate. display( model.options['grid'] )","title":"Model API"},{"location":"model_api/#model-api","text":"For numerical purposes, models are essentially represented as a set of symbols, calibration and functions representing the various equation types of the model. This data is held in a Model object whose API is described in this chapter. Models are usually created by writing a Yaml files as described in the the previous chapter, but as we will see below, they can also be written directly as long as they satisfy the requirements detailed below.","title":"Model API"},{"location":"model_api/#model-object","text":"As previously, let's consider, the Real Business Cycle example, from the introduction. The model object can be created using the yaml file: model = yaml_import('models/rbc.yaml') The object contains few meta-data: display( model.name ) # -> \"Real Business Cycles\" display( model.infos ) # -> {\"name\": \"Real Business Cycle\", \"filename\": \"examples/models/rbc.yaml\", \"type\": \"dtcc\"}","title":"Model Object"},{"location":"model_api/#calibration","text":"Each models stores calibration information as model.calibration . It is a special dictionary-like object, which contains calibration information, that is values for parameters and initial values (or steady-state) for all other variables of the model. It is possible to retrieve one or several variables calibrations: display( model.calibration['k'] ) # -> 2.9 display( model.calibration['k', 'delta'] # -> [2.9, 0.08] When a key coresponds to one of the symbols group, one gets one or several vectors of variables instead: model.calibration['states'] # - > np.array([2.9, 0]) (values of states [z, k]) model.calibration['states', 'controls'] # -> [np.array([2.9, 0]), np.array([0.29, 1.0])] To get regular dictionary mapping states groups and vectors, one can use the attributed .grouped The values are vectors (1d numpy arrays) of values for each symbol group. For instance the following code will print the calibrated values of the parameters: for (variable_group, variables) in model.calibration.items(): print(variables_group, variables) In order to get a (key,values) of all the values of the model, one can call model.calibration.flat . for (variable_group, variables) in model.calibration.items(): print(variables_group, variables) Note The calibration object can contain values that are not symbols of the model. These values can be used to calibrate model parameters and are also evaluated in the other yaml sections, using the supplied value. One uses the model.set_calibration() routine to change the calibration of the model. This one takes either a dict as an argument, or a set of keyword arguments. Both calls are valid: model.set_calibration( {'delta':0.01} ) model.set_calibration( {'i': 'delta*k'} ) model.set_calibration( delta=0.08, k=2.8 ) This method also understands symbolic expressions (as string) which makes it possible to define symbols as a function of other symbols: model.set_calibration(beta='1/(1+delta)') print(model.get_calibration('beta')) # -> nan model.set_calibration(delta=0.04) print(model.get_calibration(['beta', 'delta'])) # -> [0.96, 0.04] Under the hood, the method stores the symbolic relations between symbols. It is precisely equivalent to use the set_calibration method or to change the values in the yaml files. In particular, the calibration order is irrelevant as long as all parameters can be deduced one from another.","title":"Calibration"},{"location":"model_api/#functions","text":"A model of a specific type can feature various kinds of functions. For instance, a continuous-states-continuous-controls models, solved by iterating on the Euler equations may feature a transition equation g g and an arbitrage equation f f . Their signature is respectively s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) s_t=g(m_{t-1},s_{t-1},x_{t-1},m_t) and E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] E_t[f(m_t,s_t,x_t,s_{t+1},x_{t+1},m_{t+1})] , where s_t s_t , x_t x_t and m_t m_t respectively represent a vector of states, controls and exogenous shock. Implicitly, all functions are also assumed to depend on the vector of parameters p p . These functions can be accessed by their type in the model.functions dictionary: g = model.functions['transition'] f = model.functions['arbitrage'] Let's call the arbitrage function on the steady-state value, to see the residuals at the deterministic steady-state: m = model.calibration[\"exogenous\"] s = model.calibration[\"states\"] x = model.calibration[\"controls\"] p = model.calibration[\"parameters\"] res = f(m,s,x,m,s,x,p) display(res) The output ( res ) is two element vector, representing the residuals of the two arbitrage equations at the steady-state. It should be full of zero. Is it ? Great ! By inspecting the arbitrage function ( f? ), one can see that its call api is: f(m,s,x,M,S,X,p,diff=False,out=None) Since m , s and x are the short names for exogenous shocks, states and controls, their values at date t+1 t+1 is denoted with S and X . This simple convention prevails in most of dolo source code: when possible, vectors at date t are denoted with lowercase, while future vectors are with upper case. We have already commented the presence of the parameter vector p . Now, the generated functions also gives the option to perform in place computations, when an output vector is given: out = numpy.ones(2) f(m,s,x,m,s,x,p,out) # out now contains zeros It is also possible to compute derivatives of the function by setting diff=True . In that case, the residual and jacobians with respect to the various arguments are returned as a list: r, r_m, r_s, r_x, r_M, r_S, r_X = f(m,s,x,m,s,x,p,diff=True) Since there are two states and two controls, the variables r_s, r_x, r_S, r_X are all 2 by 2 matrices. The generated functions also allow for efficient vectorized evaluation. In order to evaluate the residuals :math: N times, one needs to supply matrix arguments, instead of vectors, so that each line corresponds to one value to evaluate as in the following example: N = 10000 vec_m = m[None,:].repeat(N, axis=0) # we repeat each line N times vec_s = s[None,:].repeat(N, axis=0) # we repeat each line N times vec_x = x[None,:].repeat(N, axis=0) vec_X = X[None,:].repeat(N, axis=0) vec_p = p[None,:].repeat(N, axis=0) # actually, except for vec_s, the function repeat is not need since broadcast rules apply vec_s[:,0] = linspace(2,4,N) # we provide various guesses for the steady-state capital vec_S = vec_s out = f(vec_m, vec_s,vec_x,vec_M, vec_S,vec_X,vec_p) # now a 10000 x 2 array out, out_m, out_s, out_x, out_M, out_S, out_X = f(vec_m, vec_s,vec_x, vec_m, vec_S,vec_X,vec_p) The vectorized evaluation is optimized so that it is much faster to make a vectorized call rather than iterate on each point. Note In the preceding example, the parameters are constant for all evaluations, yet they are repeated. This is not mandatory, and the call f(vec_m, vec_s, vec_x, vec_M, vec_S, vec_X, p) should work exactly as if p had been repeated along the first axis. We follow there numba's guvectorize conventions, even though they slightly differ from numpy's ones.","title":"Functions"},{"location":"model_api/#exogenous-shock","text":"The exogenous field contains information about the driving process. To get its default, discretized version, one can call model.exogenous.discretize() .","title":"Exogenous shock"},{"location":"model_api/#options-structure","text":"The model.options structure holds an information required by a particular solution method. For instance, for global methods, model.options['grid'] is supposed to hold the boundaries and the number nodes at which to interpolate. display( model.options['grid'] )","title":"Options structure"},{"location":"model_specification/","text":"Model Specification Variables Variable types The following types of variables can be used in models: exogenous ( m ) (can be autocorrelated) states ( s ) controls ( x ) rewards ( r ) values ( v ) expectations ( z ) parameters ( p ) Symbol types that are present in a model are always listed in that order. State-space The unknown vector of controls x x is a function \\varphi \\varphi of the states, both exogenous ( m m ) and endogenous ( s s ) In general we have: x = \\varphi(m, s) x = \\varphi(m, s) In case the exogenous process is iid, dolo looks for a decision rule x=\\varphi(s) x=\\varphi(s) . Info This fact must be kept in mind when designing a model. TODO: explain how one can get the RBC wrong... The function \\varphi \\varphi is typically approximated by the solution algorithm. It can be either a Taylor expansion, or an intepolating object (splines, smolyak). In both cases, it behaves like a numpy gufunc and can be called on a vector or a list of points: # for an iid model dr = perturb(model) m0, s0 = model.calibration['exogenous', 'states'] dr(m0, s0) # evaluates on a vector dr(m0, s0[None,:].repeat(10, axis=0) ) # works on a list of points too Equations Valid equations The various equations that can be defined using these symbol types is summarized in the following table. They are also reviewed below with more details. Function Standard name Short name Definition Transitions transition g s = g(m(-1), s(-1),x(-1),m) Lower bound controls_lb lb x_lb = lb(m, s) Upper bound controls_ub ub x_ub = ub(m, s) Utility utility u r = u(m,s,x) Value updating alue_updating v w = v(s,x,v,s(1),x(1),w(1)) Arbitrage arbitrage f 0=f(m,s,x,m(1),s(1),x(1)) Expectations expectation h z=h(s(1),x(1)) Generalized expectations expectation_2 h_2 z=h_2(s,x,m(1),s(1),x(1)) Arbitrage (explicit expectations) arbitrage_2 f_2 0=f_2(s,x,z) Direct response direct_response d x=d(s,z) When present these functions can be accessed from the model.functions dictionary by using the standard name. For instance to compute the auxiliary variables at the steady-state one can compute: # recover steady-state values e = model.calibration['exogenous'] s = model.calibration['states'] x = model.calibration['controls'] p = model.calibration['parameters'] # compute the vector of auxiliary variables a = model.functions['auxiliary'] y = a(e,s,x,p) # it should correspond to the calibrated values: calib_y = model.calibration['auxiliaries'] assert( abs(y - calib_y).max() < 0.0000001 ) Equation Types Transitions - name: `transition` - short name: `g` Transitions are given by a function g g such that at all times: s_t = g(m_{t-1}, s_{t-1}, x_{t-1}, m_t) s_t = g(m_{t-1}, s_{t-1}, x_{t-1}, m_t) where m_t m_t is a vector of exogenous shocks Example In the RBC model, the vector of states is s_t=(a_t,k_t) s_t=(a_t,k_t) . The transitions are: \\begin{eqnarray}a_t &= & \\rho a_{t-1} + \\epsilon_t\\\\ k_t & = & (1-\\delta) k_{t-1} + i_{t-1}\\end{eqnarray} \\begin{eqnarray}a_t &= & \\rho a_{t-1} + \\epsilon_t\\\\ k_t & = & (1-\\delta) k_{t-1} + i_{t-1}\\end{eqnarray} The yaml file is amended with: symbols: states: [a,k] controls: [i] shocks: [\u03f5] ... equations: transition: a[t] = rho*a[t-1] + \u03f5[t] k = k[t-1]*(1-\u03b4) + i[t-1] Note that the transitions are given in the declaration order. Auxiliary variables - name: `auxiliary` - short name: `a` In order to reduce the number of variables, it is useful to define auxiliary variables y_t y_t using a function a a such that: y_t = a(m_t, s_t, x_t) y_t = a(m_t, s_t, x_t) When they appear in an equation they are automatically substituted by the corresponding expression in m_t m_t , s_t s_t and x_t x_t . Note that auxiliary variables are not explicitely listed in the following definition. Implicitly, wherever states and controls are allowed with the same date in an equation type, then auxiliary variable are also allowed as long as the variables, they depend on are allowed. Auxiliary variables are defined in a special definitions block. Example In the RBC model, three auxiliary variables are defined y_t, c_t, r_{k,t} y_t, c_t, r_{k,t} and w_t w_t . They are a closed form function of a_t, k_t, i_t, n_t a_t, k_t, i_t, n_t . Defining these variables speeds up computation since they are don't need to be solved for or interpolated. Utility function and Bellman equation - name: `utility` - short name: `u` The (separable) value equation defines the value v_t v_t of a given policy as: v_t = u(m_t, s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] v_t = u(m_t, s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] This gives rise to the Bellman equation: v_t = \\max_{x_t} \\left( u(m_t,s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] \\right) v_t = \\max_{x_t} \\left( u(m_t,s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] \\right) These two equations are characterized by the reward function u u and the discount rate \\beta \\beta . Function u u defines the vector of symbols rewards . Since the definition of u u alone is not sufficient, the parameter used for the discount factor must be given to routines that compute the value. Several values can be computed at once, if U U is a vector function and \\beta \\beta a vector of discount factors, but in that case in cannot be used to solve for the Bellman equation. Example Our RBC example defines the value as v_t = \\frac{(c_t)^{1-\\gamma}}{1-\\gamma} + \\beta E_t v_{t+1} v_t = \\frac{(c_t)^{1-\\gamma}}{1-\\gamma} + \\beta E_t v_{t+1} . This information is coded using: ## TODO add labour to utility symbols: ... rewards: [r] equations: ... utility: - r[t] = c[t]^(1-\u03b3)/(1-\u03b3) calibration: ... beta: 0.96 # beta is the default name of the discount Value - name: `value` - short name: `w` A more general updating equation can be useful to express non-separable utilities or prices. the vector of (generalized) values v^{*} v^{*} are defined by a function w such that: v_t = w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) v_t = w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) As in the separable case, this function can either be used to compute the value of a given policy x=\\varphi() x=\\varphi() or in order solve the generalized Bellman equation: v_t = \\max_{x_t} \\left( w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) \\right) v_t = \\max_{x_t} \\left( w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) \\right) Example Instead of defining the rewards of the RBC example, one can instead define a value updating equation instead: symbols: ... values: [v] equations: ... value: - v[t] = c[t]^(1-\u03b3)/(1-\u03b3)*(1-n[t]) + \u03b2*v[t+1] Boundaries - name: `controls_lb` and `controls_ub` - short name: `lb` and `ub` The optimal controls must also satisfy bounds that are function of states. There are two functions \\underline{b}() \\underline{b}() and \\overline{b}() \\overline{b}() such that: \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, /s_t) \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, /s_t) Example In our formulation of the RBC model we have excluded negative investment, implying i_t \\geq 0 i_t \\geq 0 . On the other hand, labour cannot be negative so that we add lower bounds to the model: equations: ... controls_lb: i = 0 n = 0 TODO: this makes no sense. Specifying the lower bound on labour actually has no effect since agents endogeneously choose to work a positive amount of time in order to produce some consumption goods. As for upper bounds, it is not necessary to impose some: the maximum amount of investment is limited by the Inada conditions on consumption. As for labour n , it can be arbitrarily large without creating any paradox. Thus the upper bounds are omitted (and internally treated as infinite values). Euler equation - name: `arbitrage` (`equilibrium`) - short name: `f` A general formulation of the Euler equation is: 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] Note that the Euler equation and the boundaries interact via \"complementarity conditions\". Evaluated at one given state, with the vector of controls x=(x_1, ..., x_i, ..., x_{n_x}) x=(x_1, ..., x_i, ..., x_{n_x}) , the Euler equation gives us the residuals r=(f_1, ..., f_i, ..., f_{n_x}) r=(f_1, ..., f_i, ..., f_{n_x}) . Suppose that the i i -th control x_i x_i is supposed to lie in the interval [ \\underline{b}_i, \\overline{b}_i ] [ \\underline{b}_i, \\overline{b}_i ] . Then one of the following conditions must be true: f_i f_i = 0 f_i<0 f_i<0 and x_i=\\overline{b}_i x_i=\\overline{b}_i f_i>0 f_i>0 and x_i=\\underline{b}_i x_i=\\underline{b}_i By definition, this set of conditions is denoted by: f_i = 0 \\perp \\underline{b}_i \\leq x_i \\leq \\overline{b}_i f_i = 0 \\perp \\underline{b}_i \\leq x_i \\leq \\overline{b}_i These notations extend to a vector setting so that the Euler equations can also be written: 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) Specifying the boundaries together with Euler equation, or providing them separately is exactly equivalent. In any case, when the boundaries are finite and occasionally binding, some attention should be devoted to write the Euler equations in a consistent manner. In particular, note that the Euler equations are order-sensitive. The Euler conditions, together with the complementarity conditions typically often come from Kuhn-Tucker conditions associated with the Bellman problem, but that is not true in general. Example The RBC model has two Euler equations associated with investment and labour supply respectively. They are added to the model as: arbitrage: - 1 - beta*(c[t]/c[t+1])^(sigma)*(1-delta+rk[t+1]) \u27c2 0 <= i[t] <= inf - w - chi*n[t]^eta*c[t]^sigma \u27c2 0 <= n[t] <= inf Putting the complementarity conditions close to the Euler equations, instead of entering them as separate equations, helps to check the sign of the Euler residuals when constraints are binding. Here, when investment is less desirable, the first expression becomes bigger. When the representative is prevented to invest less due to the constraint (i.e. i_t=0 i_t=0 ), the expression is then positive consistently with the complementarity conventions. Expectations - name: `expectation` - short name: `h` The vector of explicit expectations z_t z_t is defined by a function h h such that: z_t = E_t \\left[ h(m_{t+1}, s_{t+1},x_{t+1}) \\right] z_t = E_t \\left[ h(m_{t+1}, s_{t+1},x_{t+1}) \\right] Example In the RBC example, one can define. the expected value tomorrow of one additional unit invested tomorrow: m_t=\\beta c_{t+1}^{-\\sigma}*(1-\\delta+r_{k,t+1}) m_t=\\beta c_{t+1}^{-\\sigma}*(1-\\delta+r_{k,t+1}) It is a pure expectational variable in the sense that it is solely determined by future states and decisions. In the model file, it would be defined as: symbols: ... expectations: [z] equations: expectations: - z = beta*(c[t+1])^(-sigma)*(1-delta+rk[t+1]) Generalized expectations - name: `expectation_2` - short name: `h_2` The vector of generalized explicit expectations z_t z_t is defined by a function h^{\\star} h^{\\star} such that: z_t = E_t \\left[ h^{\\star}(m_t, s_t,x_t,m_{t+1},s_{t+1},x_{t+1}) \\right] z_t = E_t \\left[ h^{\\star}(m_t, s_t,x_t,m_{t+1},s_{t+1},x_{t+1}) \\right] Euler equation with expectations - name: `arbitrage_2` (`equilibrium_2`) - short name: `f_2` If expectations are defined using one of the two preceding definitions, the Euler equation can be rewritten as: 0 = f(m_t, s_t, x_t, z_t) \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) 0 = f(m_t, s_t, x_t, z_t) \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) Note Given the definition of the expectation variable m_t m_t , today's consumption is given by: c_t = z_t^{-\\frac{1}{sigma}} c_t = z_t^{-\\frac{1}{sigma}} so the Euler equations are rewritten as: arbitrage_2: - 1 - beta*(c[t])^(sigma)/m[t] | 0 <= i[t] <= inf - w[t] - chi*n[t]^eta*c[t]^sigma | 0 <= n[t] <= inf Note the type of the arbitrage equation ( arbitrage_2 instead of arbitrage ). However c_t c_t is not a control itself, but the controls i_t, n_t i_t, n_t can be easily deduced: \\begin{eqnarray} n_t & =& ((1-\\alpha) z_t k_t^\\alpha \\frac{m_t}{\\chi})^{\\frac{1}{\\eta+\\alpha}} \\\\ i_t & = & z_t k_t^{\\alpha} n_t^{1-\\alpha} - (m_t)^{-\\frac{1}{\\sigma}} \\end{eqnarray} \\begin{eqnarray} n_t & =& ((1-\\alpha) z_t k_t^\\alpha \\frac{m_t}{\\chi})^{\\frac{1}{\\eta+\\alpha}} \\\\ i_t & = & z_t k_t^{\\alpha} n_t^{1-\\alpha} - (m_t)^{-\\frac{1}{\\sigma}} \\end{eqnarray} This translates into the following YAML code: arbitrage_2: - n[t] = ((1-alpha)*a[t]*k[t]^alpha*m[t]/chi)^(1/(eta+alpha)) - i[t] = z[t]*k[t]^alpha*n[t]^(1-alpha) - m[t]^(-1/sigma) Direct response function - name: `direct_response` - short name: `d` In some simple cases, there a function d() d() giving an explicit definition of the controls: x_t = d(m_t, s_t, z_t) x_t = d(m_t, s_t, z_t) Compared to the preceding Euler equation, this formulation saves computational time by removing the need to solve a nonlinear system to recover the controls implicitly defined by the Euler equation.","title":"Model Specification"},{"location":"model_specification/#model-specification","text":"","title":"Model Specification"},{"location":"model_specification/#variables","text":"","title":"Variables"},{"location":"model_specification/#variable-types","text":"The following types of variables can be used in models: exogenous ( m ) (can be autocorrelated) states ( s ) controls ( x ) rewards ( r ) values ( v ) expectations ( z ) parameters ( p ) Symbol types that are present in a model are always listed in that order.","title":"Variable types"},{"location":"model_specification/#state-space","text":"The unknown vector of controls x x is a function \\varphi \\varphi of the states, both exogenous ( m m ) and endogenous ( s s ) In general we have: x = \\varphi(m, s) x = \\varphi(m, s) In case the exogenous process is iid, dolo looks for a decision rule x=\\varphi(s) x=\\varphi(s) . Info This fact must be kept in mind when designing a model. TODO: explain how one can get the RBC wrong... The function \\varphi \\varphi is typically approximated by the solution algorithm. It can be either a Taylor expansion, or an intepolating object (splines, smolyak). In both cases, it behaves like a numpy gufunc and can be called on a vector or a list of points: # for an iid model dr = perturb(model) m0, s0 = model.calibration['exogenous', 'states'] dr(m0, s0) # evaluates on a vector dr(m0, s0[None,:].repeat(10, axis=0) ) # works on a list of points too","title":"State-space"},{"location":"model_specification/#equations","text":"","title":"Equations"},{"location":"model_specification/#valid-equations","text":"The various equations that can be defined using these symbol types is summarized in the following table. They are also reviewed below with more details. Function Standard name Short name Definition Transitions transition g s = g(m(-1), s(-1),x(-1),m) Lower bound controls_lb lb x_lb = lb(m, s) Upper bound controls_ub ub x_ub = ub(m, s) Utility utility u r = u(m,s,x) Value updating alue_updating v w = v(s,x,v,s(1),x(1),w(1)) Arbitrage arbitrage f 0=f(m,s,x,m(1),s(1),x(1)) Expectations expectation h z=h(s(1),x(1)) Generalized expectations expectation_2 h_2 z=h_2(s,x,m(1),s(1),x(1)) Arbitrage (explicit expectations) arbitrage_2 f_2 0=f_2(s,x,z) Direct response direct_response d x=d(s,z) When present these functions can be accessed from the model.functions dictionary by using the standard name. For instance to compute the auxiliary variables at the steady-state one can compute: # recover steady-state values e = model.calibration['exogenous'] s = model.calibration['states'] x = model.calibration['controls'] p = model.calibration['parameters'] # compute the vector of auxiliary variables a = model.functions['auxiliary'] y = a(e,s,x,p) # it should correspond to the calibrated values: calib_y = model.calibration['auxiliaries'] assert( abs(y - calib_y).max() < 0.0000001 )","title":"Valid equations"},{"location":"model_specification/#equation-types","text":"","title":"Equation Types"},{"location":"model_specification/#transitions","text":"- name: `transition` - short name: `g` Transitions are given by a function g g such that at all times: s_t = g(m_{t-1}, s_{t-1}, x_{t-1}, m_t) s_t = g(m_{t-1}, s_{t-1}, x_{t-1}, m_t) where m_t m_t is a vector of exogenous shocks Example In the RBC model, the vector of states is s_t=(a_t,k_t) s_t=(a_t,k_t) . The transitions are: \\begin{eqnarray}a_t &= & \\rho a_{t-1} + \\epsilon_t\\\\ k_t & = & (1-\\delta) k_{t-1} + i_{t-1}\\end{eqnarray} \\begin{eqnarray}a_t &= & \\rho a_{t-1} + \\epsilon_t\\\\ k_t & = & (1-\\delta) k_{t-1} + i_{t-1}\\end{eqnarray} The yaml file is amended with: symbols: states: [a,k] controls: [i] shocks: [\u03f5] ... equations: transition: a[t] = rho*a[t-1] + \u03f5[t] k = k[t-1]*(1-\u03b4) + i[t-1] Note that the transitions are given in the declaration order.","title":"Transitions"},{"location":"model_specification/#auxiliary-variables","text":"- name: `auxiliary` - short name: `a` In order to reduce the number of variables, it is useful to define auxiliary variables y_t y_t using a function a a such that: y_t = a(m_t, s_t, x_t) y_t = a(m_t, s_t, x_t) When they appear in an equation they are automatically substituted by the corresponding expression in m_t m_t , s_t s_t and x_t x_t . Note that auxiliary variables are not explicitely listed in the following definition. Implicitly, wherever states and controls are allowed with the same date in an equation type, then auxiliary variable are also allowed as long as the variables, they depend on are allowed. Auxiliary variables are defined in a special definitions block. Example In the RBC model, three auxiliary variables are defined y_t, c_t, r_{k,t} y_t, c_t, r_{k,t} and w_t w_t . They are a closed form function of a_t, k_t, i_t, n_t a_t, k_t, i_t, n_t . Defining these variables speeds up computation since they are don't need to be solved for or interpolated.","title":"Auxiliary variables"},{"location":"model_specification/#utility-function-and-bellman-equation","text":"- name: `utility` - short name: `u` The (separable) value equation defines the value v_t v_t of a given policy as: v_t = u(m_t, s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] v_t = u(m_t, s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] This gives rise to the Bellman equation: v_t = \\max_{x_t} \\left( u(m_t,s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] \\right) v_t = \\max_{x_t} \\left( u(m_t,s_t,x_t) + \\beta E_t \\left[ v_{t+1} \\right] \\right) These two equations are characterized by the reward function u u and the discount rate \\beta \\beta . Function u u defines the vector of symbols rewards . Since the definition of u u alone is not sufficient, the parameter used for the discount factor must be given to routines that compute the value. Several values can be computed at once, if U U is a vector function and \\beta \\beta a vector of discount factors, but in that case in cannot be used to solve for the Bellman equation. Example Our RBC example defines the value as v_t = \\frac{(c_t)^{1-\\gamma}}{1-\\gamma} + \\beta E_t v_{t+1} v_t = \\frac{(c_t)^{1-\\gamma}}{1-\\gamma} + \\beta E_t v_{t+1} . This information is coded using: ## TODO add labour to utility symbols: ... rewards: [r] equations: ... utility: - r[t] = c[t]^(1-\u03b3)/(1-\u03b3) calibration: ... beta: 0.96 # beta is the default name of the discount","title":"Utility function and Bellman equation"},{"location":"model_specification/#value","text":"- name: `value` - short name: `w` A more general updating equation can be useful to express non-separable utilities or prices. the vector of (generalized) values v^{*} v^{*} are defined by a function w such that: v_t = w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) v_t = w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) As in the separable case, this function can either be used to compute the value of a given policy x=\\varphi() x=\\varphi() or in order solve the generalized Bellman equation: v_t = \\max_{x_t} \\left( w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) \\right) v_t = \\max_{x_t} \\left( w(m_t,s_t,x_t,v_t,m_{t+1},s_{t+1},x_{t+1},v_{t+1}) \\right) Example Instead of defining the rewards of the RBC example, one can instead define a value updating equation instead: symbols: ... values: [v] equations: ... value: - v[t] = c[t]^(1-\u03b3)/(1-\u03b3)*(1-n[t]) + \u03b2*v[t+1]","title":"Value"},{"location":"model_specification/#boundaries","text":"- name: `controls_lb` and `controls_ub` - short name: `lb` and `ub` The optimal controls must also satisfy bounds that are function of states. There are two functions \\underline{b}() \\underline{b}() and \\overline{b}() \\overline{b}() such that: \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, /s_t) \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, /s_t) Example In our formulation of the RBC model we have excluded negative investment, implying i_t \\geq 0 i_t \\geq 0 . On the other hand, labour cannot be negative so that we add lower bounds to the model: equations: ... controls_lb: i = 0 n = 0 TODO: this makes no sense. Specifying the lower bound on labour actually has no effect since agents endogeneously choose to work a positive amount of time in order to produce some consumption goods. As for upper bounds, it is not necessary to impose some: the maximum amount of investment is limited by the Inada conditions on consumption. As for labour n , it can be arbitrarily large without creating any paradox. Thus the upper bounds are omitted (and internally treated as infinite values).","title":"Boundaries"},{"location":"model_specification/#euler-equation","text":"- name: `arbitrage` (`equilibrium`) - short name: `f` A general formulation of the Euler equation is: 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] Note that the Euler equation and the boundaries interact via \"complementarity conditions\". Evaluated at one given state, with the vector of controls x=(x_1, ..., x_i, ..., x_{n_x}) x=(x_1, ..., x_i, ..., x_{n_x}) , the Euler equation gives us the residuals r=(f_1, ..., f_i, ..., f_{n_x}) r=(f_1, ..., f_i, ..., f_{n_x}) . Suppose that the i i -th control x_i x_i is supposed to lie in the interval [ \\underline{b}_i, \\overline{b}_i ] [ \\underline{b}_i, \\overline{b}_i ] . Then one of the following conditions must be true: f_i f_i = 0 f_i<0 f_i<0 and x_i=\\overline{b}_i x_i=\\overline{b}_i f_i>0 f_i>0 and x_i=\\underline{b}_i x_i=\\underline{b}_i By definition, this set of conditions is denoted by: f_i = 0 \\perp \\underline{b}_i \\leq x_i \\leq \\overline{b}_i f_i = 0 \\perp \\underline{b}_i \\leq x_i \\leq \\overline{b}_i These notations extend to a vector setting so that the Euler equations can also be written: 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) 0 = E_t \\left[ f(m_t, s_t, x_t, m_{t+1}, s_{t+1}, x_{t+1}) \\right] \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) Specifying the boundaries together with Euler equation, or providing them separately is exactly equivalent. In any case, when the boundaries are finite and occasionally binding, some attention should be devoted to write the Euler equations in a consistent manner. In particular, note that the Euler equations are order-sensitive. The Euler conditions, together with the complementarity conditions typically often come from Kuhn-Tucker conditions associated with the Bellman problem, but that is not true in general. Example The RBC model has two Euler equations associated with investment and labour supply respectively. They are added to the model as: arbitrage: - 1 - beta*(c[t]/c[t+1])^(sigma)*(1-delta+rk[t+1]) \u27c2 0 <= i[t] <= inf - w - chi*n[t]^eta*c[t]^sigma \u27c2 0 <= n[t] <= inf Putting the complementarity conditions close to the Euler equations, instead of entering them as separate equations, helps to check the sign of the Euler residuals when constraints are binding. Here, when investment is less desirable, the first expression becomes bigger. When the representative is prevented to invest less due to the constraint (i.e. i_t=0 i_t=0 ), the expression is then positive consistently with the complementarity conventions.","title":"Euler equation"},{"location":"model_specification/#expectations","text":"- name: `expectation` - short name: `h` The vector of explicit expectations z_t z_t is defined by a function h h such that: z_t = E_t \\left[ h(m_{t+1}, s_{t+1},x_{t+1}) \\right] z_t = E_t \\left[ h(m_{t+1}, s_{t+1},x_{t+1}) \\right] Example In the RBC example, one can define. the expected value tomorrow of one additional unit invested tomorrow: m_t=\\beta c_{t+1}^{-\\sigma}*(1-\\delta+r_{k,t+1}) m_t=\\beta c_{t+1}^{-\\sigma}*(1-\\delta+r_{k,t+1}) It is a pure expectational variable in the sense that it is solely determined by future states and decisions. In the model file, it would be defined as: symbols: ... expectations: [z] equations: expectations: - z = beta*(c[t+1])^(-sigma)*(1-delta+rk[t+1])","title":"Expectations"},{"location":"model_specification/#generalized-expectations","text":"- name: `expectation_2` - short name: `h_2` The vector of generalized explicit expectations z_t z_t is defined by a function h^{\\star} h^{\\star} such that: z_t = E_t \\left[ h^{\\star}(m_t, s_t,x_t,m_{t+1},s_{t+1},x_{t+1}) \\right] z_t = E_t \\left[ h^{\\star}(m_t, s_t,x_t,m_{t+1},s_{t+1},x_{t+1}) \\right]","title":"Generalized expectations"},{"location":"model_specification/#euler-equation-with-expectations","text":"- name: `arbitrage_2` (`equilibrium_2`) - short name: `f_2` If expectations are defined using one of the two preceding definitions, the Euler equation can be rewritten as: 0 = f(m_t, s_t, x_t, z_t) \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) 0 = f(m_t, s_t, x_t, z_t) \\perp \\underline{b}(m_t, s_t) \\leq x_t \\leq \\overline{b}(m_t, s_t) Note Given the definition of the expectation variable m_t m_t , today's consumption is given by: c_t = z_t^{-\\frac{1}{sigma}} c_t = z_t^{-\\frac{1}{sigma}} so the Euler equations are rewritten as: arbitrage_2: - 1 - beta*(c[t])^(sigma)/m[t] | 0 <= i[t] <= inf - w[t] - chi*n[t]^eta*c[t]^sigma | 0 <= n[t] <= inf Note the type of the arbitrage equation ( arbitrage_2 instead of arbitrage ). However c_t c_t is not a control itself, but the controls i_t, n_t i_t, n_t can be easily deduced: \\begin{eqnarray} n_t & =& ((1-\\alpha) z_t k_t^\\alpha \\frac{m_t}{\\chi})^{\\frac{1}{\\eta+\\alpha}} \\\\ i_t & = & z_t k_t^{\\alpha} n_t^{1-\\alpha} - (m_t)^{-\\frac{1}{\\sigma}} \\end{eqnarray} \\begin{eqnarray} n_t & =& ((1-\\alpha) z_t k_t^\\alpha \\frac{m_t}{\\chi})^{\\frac{1}{\\eta+\\alpha}} \\\\ i_t & = & z_t k_t^{\\alpha} n_t^{1-\\alpha} - (m_t)^{-\\frac{1}{\\sigma}} \\end{eqnarray} This translates into the following YAML code: arbitrage_2: - n[t] = ((1-alpha)*a[t]*k[t]^alpha*m[t]/chi)^(1/(eta+alpha)) - i[t] = z[t]*k[t]^alpha*n[t]^(1-alpha) - m[t]^(-1/sigma)","title":"Euler equation with expectations"},{"location":"model_specification/#direct-response-function","text":"- name: `direct_response` - short name: `d` In some simple cases, there a function d() d() giving an explicit definition of the controls: x_t = d(m_t, s_t, z_t) x_t = d(m_t, s_t, z_t) Compared to the preceding Euler equation, this formulation saves computational time by removing the need to solve a nonlinear system to recover the controls implicitly defined by the Euler equation.","title":"Direct response function"},{"location":"modeling_language/","text":"The dolo language The easiest way to code a model in dolo consists in using specialized Yaml files also referred to as dolo model files. YAML format YAML stands for Yet Another Markup Language. It is a serialization language that allows complex data structures in a human-readable way. Atomic elements are floats, integers and strings. An ordered list can be defined by separating elements with commas and enclosing them with squere brackets: [1,2,3] Equivalently, it can be done on several line, by prepending [-]{.title-ref} to each line - 'element' - element # quotes are optional there is no ambiguity - third element # this is interpreted as ``'third element'`` Associative arrays map keys to (simple strings to arbitrary values) as in the following example: {age: 18, name: peter} Mappings can also be defined on severaly lines, and as in Python, structures can be nested by using indentation (use spaces no tabs): age: 18 name: peter occupations: - school - guitar friends: paula: {age: 18} The correspondance between the yaml definition and the resulting Python object is very transparent. YAML mappings and lists are converted to Python dictionaries and lists respectiveley. Note TODO say something about YAML objects Any model file must be syntactically correct in the Yaml sense, before the content is analysed further. More information about the YAML syntax can be found on the YAML website , especially from the language specification . Example Here is an example model contained in the file examples\\models\\rbc.yaml name: Real Business Cycle symbols: exogenous: [e_z] states: [z, k] controls: [n, i] parameters: [beta, sigma, eta, chi, delta, alpha, rho, zbar, sig_z] definitions: | y[t] = exp(z[t])*k[t]^alpha*n[t]^(1-alpha) c[t] = y[t] - i[t] rk[t] = alpha*y[t]/k[t] w[t] = (1-alpha)*y[t]/n[t] equations: arbitrage: | chi*n[t]^eta*c[t]^sigma - w[t] \u27c2 0.0 <= n[t] <= inf 1 - beta*(c[t]/c[t+1])^(sigma)*(1-delta+rk[t+1]) \u27c2 -inf <= i[t] <= inf transition: | z[t] = rho*z[t-1] + e_z k[t] = (1-delta)*k[t-1] + i[t-1] calibration: # parameters beta : 0.99 phi: 1 delta : 0.025 alpha : 0.33 rho : 0.8 sigma: 5 eta: 1 sig_z: 0.016 zbar: 0 chi : w/c^sigma/n^eta c_i: 1.5 c_y: 0.5 e_z: 0.0 n: 0.33 z: zbar rk: 1/beta-1+delta w: (1-alpha)*exp(z)*(k/n)^(alpha) k: n/(rk/alpha)^(1/(1-alpha)) y: exp(z)*k^alpha*n^(1-alpha) i: delta*k c: y - i V: log(c)/(1-beta) u: c^(1-sigma)/(1-sigma) - chi*n^(1+eta)/(1+eta) m: beta/c^sigma*(1-delta+rk) kss: 10 exogenous: !UNormal sigma: 0.01 domain: z: [-2*sig_z/(1-rho^2)^0.5, 2*sig_z/(1-rho^2)^0.5] k: [ kss*0.5, kss*1.5] options: grid: !Cartesian n: [100, 100] discrete_choices: [n] This model can be loaded using the command: model = yaml_import(`examples/models/rbc.yaml`) The function yaml_import (cross) will raise errors until the model satisfies basic compliance tests. . In the following subsections, we describe the various syntactic rules prevailing while writing yaml files. Sections A dolo model consists in the following 4 or 5 parts: a symbols section where all symbols used in the model must be defined an equations section containing the list of equations a calibration section providing numeric values for the symbols a domain section, with the information about the solution domain an options section containing additional informations an exogenous section where exogenous shocks are defined. These section have context dependent rules. We now review each of them in detail: Declaration section This section is introduced by the symbols ]{.title-ref}` keyword. All symbols appearing in the model must be defined there. Symbols must be valid Python identifiers (alphanumeric not beginning with a number) and are case sensitive. Greek letters are recognized. Subscripts and superscripts can be denoted by _ and __ respectively. For instance beta_i_1__d will be pretty printed as \\beta_{i,1}^d \\beta_{i,1}^d . Unicode characters are accepted too, as long as they are valid, when used within python identifiers. Note In most modern text editor, greek characters can be typed, by entering their latex representation (like beta ) and pressing Tab. Symbols are sorted by type as in the following example: symbols: states: [a, b] controls: [u, v] exogenous: [e] parameters: [rho] Note that each type of symbol is associated with a symbol list (like [a,b] ). Alert A common mistake consists in forgetting the commas, and use spaces only inside list. This doesn't work since the space will be ignored and the two symbols recognized as one. The exact list of symbols to declare depends on which algorithm is meant to be used. In general, one needs to supply at least states (endogenous states), exogenous (for exogenous shocks), controls for decision variables, and parameters for scalar parameters, that the model can depend on. Declaration of equations The equations section contains blocks of equations sorted by type. Expressions follow (roughly) the Dynare conventions. Common arithmetic operators ([+,-,*,/,\\^]{.title-ref}) are allowed with conventional priorities as well as usual functions ( sqrt , log , exp , sin , cos , tan , asin , acos , atan , sinh , cosh , tanh , asinh , acosh , atanh ). The definitions of these functions match the definitions from the numpy package. All symbols appearing in an expression must either be declared in the symbols section or be one of the predefined functions. Parameters (that are time invariant) are ntot subscripted, while all other symbol types, are variables, indexed by time. A variable v appear as v[t-1] (for v_{t-1} v_{t-1} ), v[t] (for v_t v_t ), or v[t+1] (for v_t v_t ). All equations are implicitly enclosed by the expectation operator E_t\\left[\\cdots \\right] E_t\\left[\\cdots \\right] . Consequently, the law of motion for the capital k_{t+1} = (1-\\delta) k_{t} + i_{t} + \\epsilon_t k_{t+1} = (1-\\delta) k_{t} + i_{t} + \\epsilon_t is written (in a transition section) as: k[t] = (1-\u03b4)*k[t-1] + i[t-1] while the Euler E_t \\left[ \\beta \\left( \\frac{c_{t+1}}{c_t} + (1-\\delta)+r_{t+1} \\right) \\right] - 1 E_t \\left[ \\beta \\left( \\frac{c_{t+1}}{c_t} + (1-\\delta)+r_{t+1} \\right) \\right] - 1 would be written (in the arbitrage section) as: \u03b2*(c[t]/c[t+1])^(\u03c3)*(1-\u03b4+r[t+1]) - 1 # note that expectiation is operator Note In Python, the exponent operator is denoted by [**]{.title-ref} while the caret operator [\\^]{.title-ref} represents bitwise XOR. In dolo models, we ignore this distinction and interpret both as an exponent. Note The default evaluator in dolo preserves the evaluation order. Thus (c[t+1]/c[t])^(-gamma) is not evaluated in the same way (and is numerically more stable) than c(1)^(-gamma)/c^(-gamma) . Currently, this is not true for symbolically computed derivatives, as expressions are automatically simplified, implying that execution order is not guaranteed. This impacts only higher order perturbations. An equation can consist of one expression, or two expressions separated by [=]{.title-ref}. There are two types of equation blocks: Condition blocks : in these blocks, each equation lhs = rhs define the scalar value (rhs)-(lhs) . A list of of such equations, i.e a block, defines a multivariate function of the appearing symbols. Certain condition blocks, can be associated with complementarity conditions separated by \u27c2 (or | ) as in rhs-lhs \u27c2 0 < x < 1 . In this case it is advised to omit the equal sign in order to make it easier to interpret the complementarity. Also, when complementarity conditions are used, the ordering of variables appearing in the complementarities must match the declaration order (more in section Y). Definition blocks : the differ from condition blocks in that they define a group of variables ( states or auxiliaries ) as a function of the right hand side. The types of variables appearing on the right hand side depend on the block type. The variables enumerated on the left hand-side must appear in the declaration order. Note In the RBC example, the definitions block defines variables ( y,c,rk,w ) that can be directly deduced from the states and the controls: definitions: - y[t] = z[t]*k[t]^alpha*n[t]^(1-alpha) - c[t] = y[t] - i[t] - rk[t] = alpha*y[t]/k[t] - w[t] = (1-alpha)*y[t]/w[t] Note that the declaration order matches the order in which variables appear on the left hand side. Also, these variables are defined recursively: c , rk and w depend on the value for y . In contrast to the calibration block, the definition order matters. Assuming that variables where listed as ( c,y,rk,w ) the following block would provide incorrect result since y is not known when c is evaluated. definitions: - c[t] = y[t] - i[t] - y[t] = z[t]*k[t]^alpha*n[t]^(1-alpha) - rk[t] = alpha*y[t]/k[t] - w[t] = (1-alpha)*y[t]/w[t] Calibration section The role of the calibration section consists in providing values for the parameters and the variables. The calibration of all parameters appearing in the equation is of course strictly necessary while the the calibration of other types of variables is useful to define the steady-state or an initial guess to the steady-state. The calibrated values are also substituted in other sections, including exgogenous and options sections. This is particularly useful to make the covariance matrix depend on model parameters, or to adapt the state-space to the model's calibration. The calibration is given by an associative dictionary mapping symbols to define with values. The values can be either a scalar or an expression. All symbols are treated in the same way, and values can depend upon each other as long as there is a way to resolve them recursively. In particular, it is possible to define a parameter in order to target a special value of an endogenous variable at the steady-state. This is done in the RBC example where steady-state labour is targeted with n: 0.33 and the parameter phi calibrated so that the optimal labour supply equation holds at the steady-state ( chi: w/c^sigma/n^eta ). All symbols that are defined in the [symbols]{.title-ref} section but do not appear in the calibration section are initialized with the value [nan]{.title-ref} without issuing any warning. Note No clear long term policy has been established yet about how to deal with undeclared symbols in the calibration section. Avoid them. TODO: reevaluate Domain section The domain section contains boundaries for each endogenous state as in the following example: domain: k: [0.5*k, 2*k] z: [-\u03c3_z*3, \u03c3_z*3] Note In the above example, values can refer to the calibration dictionary. Hence, 0.5 k means 50% of steady-state k . Keys, are not replaced. Exogenous shocks specification Alert This section is out-of-date. Syntax has changed. Many more shocks options are allowed. See processes for a more recent description of the shocks. TODO: redo The type of exogenous shock associated to a model determines the kind of decision rule, whih will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks (Normal law), continous autocorrelated process (VAR1 process) or a discrete markov chain. The type of the shock is specified using yaml type annotations (starting with exclamation mark) The exogenous shock section can refer to parameters specified in the calibration section. Here are some examples for each type of shock: Normal For Dynare and continuous-states models, one has to specifiy a multivariate distribution of the i.i.d. process for the vector of exogenous variaibles (otherwise they are assumed to be constantly equal to zero). This is done in the exogenous section. A gaussian distrubution (only one supported so far), is specified by supplying the covariance matrix as a list of list as in the following example. exogenous: !Normal: Sigma: [ [sigma_1, 0.0], [0.0, sigma_2] ] Alert The shocks syntax is currently rather unforgiving. Normal shocks expect a covariance matrix (i.e. a list of list) and the keyword is Sigma not sigma . Markov chains Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] It is also possible to combine markov chains together. exogenous: !Product - !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] - !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] Options The [options]{.title-ref} section contains all informations necessary to solve the model. It can also contain arbitrary additional informations. The section follows the mini-language convention, with all calibrated values replaced by scalars and all keywords allowed. Global solutions require the definition of an approximation space. The lower, upper bounds and approximation orders (number of nodes in each dimension) are defined as in the following example: options: grid: !Cartesian n: [10, 50] arbitrary_information: 42","title":"The Dolo Language"},{"location":"modeling_language/#the-dolo-language","text":"The easiest way to code a model in dolo consists in using specialized Yaml files also referred to as dolo model files.","title":"The dolo language"},{"location":"modeling_language/#yaml-format","text":"YAML stands for Yet Another Markup Language. It is a serialization language that allows complex data structures in a human-readable way. Atomic elements are floats, integers and strings. An ordered list can be defined by separating elements with commas and enclosing them with squere brackets: [1,2,3] Equivalently, it can be done on several line, by prepending [-]{.title-ref} to each line - 'element' - element # quotes are optional there is no ambiguity - third element # this is interpreted as ``'third element'`` Associative arrays map keys to (simple strings to arbitrary values) as in the following example: {age: 18, name: peter} Mappings can also be defined on severaly lines, and as in Python, structures can be nested by using indentation (use spaces no tabs): age: 18 name: peter occupations: - school - guitar friends: paula: {age: 18} The correspondance between the yaml definition and the resulting Python object is very transparent. YAML mappings and lists are converted to Python dictionaries and lists respectiveley. Note TODO say something about YAML objects Any model file must be syntactically correct in the Yaml sense, before the content is analysed further. More information about the YAML syntax can be found on the YAML website , especially from the language specification .","title":"YAML format"},{"location":"modeling_language/#example","text":"Here is an example model contained in the file examples\\models\\rbc.yaml name: Real Business Cycle symbols: exogenous: [e_z] states: [z, k] controls: [n, i] parameters: [beta, sigma, eta, chi, delta, alpha, rho, zbar, sig_z] definitions: | y[t] = exp(z[t])*k[t]^alpha*n[t]^(1-alpha) c[t] = y[t] - i[t] rk[t] = alpha*y[t]/k[t] w[t] = (1-alpha)*y[t]/n[t] equations: arbitrage: | chi*n[t]^eta*c[t]^sigma - w[t] \u27c2 0.0 <= n[t] <= inf 1 - beta*(c[t]/c[t+1])^(sigma)*(1-delta+rk[t+1]) \u27c2 -inf <= i[t] <= inf transition: | z[t] = rho*z[t-1] + e_z k[t] = (1-delta)*k[t-1] + i[t-1] calibration: # parameters beta : 0.99 phi: 1 delta : 0.025 alpha : 0.33 rho : 0.8 sigma: 5 eta: 1 sig_z: 0.016 zbar: 0 chi : w/c^sigma/n^eta c_i: 1.5 c_y: 0.5 e_z: 0.0 n: 0.33 z: zbar rk: 1/beta-1+delta w: (1-alpha)*exp(z)*(k/n)^(alpha) k: n/(rk/alpha)^(1/(1-alpha)) y: exp(z)*k^alpha*n^(1-alpha) i: delta*k c: y - i V: log(c)/(1-beta) u: c^(1-sigma)/(1-sigma) - chi*n^(1+eta)/(1+eta) m: beta/c^sigma*(1-delta+rk) kss: 10 exogenous: !UNormal sigma: 0.01 domain: z: [-2*sig_z/(1-rho^2)^0.5, 2*sig_z/(1-rho^2)^0.5] k: [ kss*0.5, kss*1.5] options: grid: !Cartesian n: [100, 100] discrete_choices: [n] This model can be loaded using the command: model = yaml_import(`examples/models/rbc.yaml`) The function yaml_import (cross) will raise errors until the model satisfies basic compliance tests. . In the following subsections, we describe the various syntactic rules prevailing while writing yaml files.","title":"Example"},{"location":"modeling_language/#sections","text":"A dolo model consists in the following 4 or 5 parts: a symbols section where all symbols used in the model must be defined an equations section containing the list of equations a calibration section providing numeric values for the symbols a domain section, with the information about the solution domain an options section containing additional informations an exogenous section where exogenous shocks are defined. These section have context dependent rules. We now review each of them in detail:","title":"Sections"},{"location":"modeling_language/#declaration-section","text":"This section is introduced by the symbols ]{.title-ref}` keyword. All symbols appearing in the model must be defined there. Symbols must be valid Python identifiers (alphanumeric not beginning with a number) and are case sensitive. Greek letters are recognized. Subscripts and superscripts can be denoted by _ and __ respectively. For instance beta_i_1__d will be pretty printed as \\beta_{i,1}^d \\beta_{i,1}^d . Unicode characters are accepted too, as long as they are valid, when used within python identifiers. Note In most modern text editor, greek characters can be typed, by entering their latex representation (like beta ) and pressing Tab. Symbols are sorted by type as in the following example: symbols: states: [a, b] controls: [u, v] exogenous: [e] parameters: [rho] Note that each type of symbol is associated with a symbol list (like [a,b] ). Alert A common mistake consists in forgetting the commas, and use spaces only inside list. This doesn't work since the space will be ignored and the two symbols recognized as one. The exact list of symbols to declare depends on which algorithm is meant to be used. In general, one needs to supply at least states (endogenous states), exogenous (for exogenous shocks), controls for decision variables, and parameters for scalar parameters, that the model can depend on.","title":"Declaration section"},{"location":"modeling_language/#declaration-of-equations","text":"The equations section contains blocks of equations sorted by type. Expressions follow (roughly) the Dynare conventions. Common arithmetic operators ([+,-,*,/,\\^]{.title-ref}) are allowed with conventional priorities as well as usual functions ( sqrt , log , exp , sin , cos , tan , asin , acos , atan , sinh , cosh , tanh , asinh , acosh , atanh ). The definitions of these functions match the definitions from the numpy package. All symbols appearing in an expression must either be declared in the symbols section or be one of the predefined functions. Parameters (that are time invariant) are ntot subscripted, while all other symbol types, are variables, indexed by time. A variable v appear as v[t-1] (for v_{t-1} v_{t-1} ), v[t] (for v_t v_t ), or v[t+1] (for v_t v_t ). All equations are implicitly enclosed by the expectation operator E_t\\left[\\cdots \\right] E_t\\left[\\cdots \\right] . Consequently, the law of motion for the capital k_{t+1} = (1-\\delta) k_{t} + i_{t} + \\epsilon_t k_{t+1} = (1-\\delta) k_{t} + i_{t} + \\epsilon_t is written (in a transition section) as: k[t] = (1-\u03b4)*k[t-1] + i[t-1] while the Euler E_t \\left[ \\beta \\left( \\frac{c_{t+1}}{c_t} + (1-\\delta)+r_{t+1} \\right) \\right] - 1 E_t \\left[ \\beta \\left( \\frac{c_{t+1}}{c_t} + (1-\\delta)+r_{t+1} \\right) \\right] - 1 would be written (in the arbitrage section) as: \u03b2*(c[t]/c[t+1])^(\u03c3)*(1-\u03b4+r[t+1]) - 1 # note that expectiation is operator Note In Python, the exponent operator is denoted by [**]{.title-ref} while the caret operator [\\^]{.title-ref} represents bitwise XOR. In dolo models, we ignore this distinction and interpret both as an exponent. Note The default evaluator in dolo preserves the evaluation order. Thus (c[t+1]/c[t])^(-gamma) is not evaluated in the same way (and is numerically more stable) than c(1)^(-gamma)/c^(-gamma) . Currently, this is not true for symbolically computed derivatives, as expressions are automatically simplified, implying that execution order is not guaranteed. This impacts only higher order perturbations. An equation can consist of one expression, or two expressions separated by [=]{.title-ref}. There are two types of equation blocks: Condition blocks : in these blocks, each equation lhs = rhs define the scalar value (rhs)-(lhs) . A list of of such equations, i.e a block, defines a multivariate function of the appearing symbols. Certain condition blocks, can be associated with complementarity conditions separated by \u27c2 (or | ) as in rhs-lhs \u27c2 0 < x < 1 . In this case it is advised to omit the equal sign in order to make it easier to interpret the complementarity. Also, when complementarity conditions are used, the ordering of variables appearing in the complementarities must match the declaration order (more in section Y). Definition blocks : the differ from condition blocks in that they define a group of variables ( states or auxiliaries ) as a function of the right hand side. The types of variables appearing on the right hand side depend on the block type. The variables enumerated on the left hand-side must appear in the declaration order. Note In the RBC example, the definitions block defines variables ( y,c,rk,w ) that can be directly deduced from the states and the controls: definitions: - y[t] = z[t]*k[t]^alpha*n[t]^(1-alpha) - c[t] = y[t] - i[t] - rk[t] = alpha*y[t]/k[t] - w[t] = (1-alpha)*y[t]/w[t] Note that the declaration order matches the order in which variables appear on the left hand side. Also, these variables are defined recursively: c , rk and w depend on the value for y . In contrast to the calibration block, the definition order matters. Assuming that variables where listed as ( c,y,rk,w ) the following block would provide incorrect result since y is not known when c is evaluated. definitions: - c[t] = y[t] - i[t] - y[t] = z[t]*k[t]^alpha*n[t]^(1-alpha) - rk[t] = alpha*y[t]/k[t] - w[t] = (1-alpha)*y[t]/w[t]","title":"Declaration of equations"},{"location":"modeling_language/#calibration-section","text":"The role of the calibration section consists in providing values for the parameters and the variables. The calibration of all parameters appearing in the equation is of course strictly necessary while the the calibration of other types of variables is useful to define the steady-state or an initial guess to the steady-state. The calibrated values are also substituted in other sections, including exgogenous and options sections. This is particularly useful to make the covariance matrix depend on model parameters, or to adapt the state-space to the model's calibration. The calibration is given by an associative dictionary mapping symbols to define with values. The values can be either a scalar or an expression. All symbols are treated in the same way, and values can depend upon each other as long as there is a way to resolve them recursively. In particular, it is possible to define a parameter in order to target a special value of an endogenous variable at the steady-state. This is done in the RBC example where steady-state labour is targeted with n: 0.33 and the parameter phi calibrated so that the optimal labour supply equation holds at the steady-state ( chi: w/c^sigma/n^eta ). All symbols that are defined in the [symbols]{.title-ref} section but do not appear in the calibration section are initialized with the value [nan]{.title-ref} without issuing any warning. Note No clear long term policy has been established yet about how to deal with undeclared symbols in the calibration section. Avoid them. TODO: reevaluate","title":"Calibration section"},{"location":"modeling_language/#domain-section","text":"The domain section contains boundaries for each endogenous state as in the following example: domain: k: [0.5*k, 2*k] z: [-\u03c3_z*3, \u03c3_z*3] Note In the above example, values can refer to the calibration dictionary. Hence, 0.5 k means 50% of steady-state k . Keys, are not replaced.","title":"Domain section"},{"location":"modeling_language/#exogenous-shocks-specification","text":"Alert This section is out-of-date. Syntax has changed. Many more shocks options are allowed. See processes for a more recent description of the shocks. TODO: redo The type of exogenous shock associated to a model determines the kind of decision rule, whih will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks (Normal law), continous autocorrelated process (VAR1 process) or a discrete markov chain. The type of the shock is specified using yaml type annotations (starting with exclamation mark) The exogenous shock section can refer to parameters specified in the calibration section. Here are some examples for each type of shock:","title":"Exogenous shocks specification"},{"location":"modeling_language/#normal","text":"For Dynare and continuous-states models, one has to specifiy a multivariate distribution of the i.i.d. process for the vector of exogenous variaibles (otherwise they are assumed to be constantly equal to zero). This is done in the exogenous section. A gaussian distrubution (only one supported so far), is specified by supplying the covariance matrix as a list of list as in the following example. exogenous: !Normal: Sigma: [ [sigma_1, 0.0], [0.0, sigma_2] ] Alert The shocks syntax is currently rather unforgiving. Normal shocks expect a covariance matrix (i.e. a list of list) and the keyword is Sigma not sigma .","title":"Normal"},{"location":"modeling_language/#markov-chains","text":"Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] It is also possible to combine markov chains together. exogenous: !Product - !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] - !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]]","title":"Markov chains"},{"location":"modeling_language/#options","text":"The [options]{.title-ref} section contains all informations necessary to solve the model. It can also contain arbitrary additional informations. The section follows the mini-language convention, with all calibrated values replaced by scalars and all keywords allowed. Global solutions require the definition of an approximation space. The lower, upper bounds and approximation orders (number of nodes in each dimension) are defined as in the following example: options: grid: !Cartesian n: [10, 50] arbitrary_information: 42","title":"Options"},{"location":"parameterized_expectations/","text":"Parameterized expectations We consider an fgh model, that is a model with the form: s_t = g\\left(s_{t-1}, x_{t-1}, \\epsilon_t \\right) s_t = g\\left(s_{t-1}, x_{t-1}, \\epsilon_t \\right) 0 = f\\left(s_{t}, x_{t}, E_t[h(s_{t+1}, x_{t+1})] \\right) 0 = f\\left(s_{t}, x_{t}, E_t[h(s_{t+1}, x_{t+1})] \\right) where g g is the state transition function, f f is the arbitrage equation, and h h is the expectations function (more accurately, it is the function over which expectations are taken). The parameterized expectations algorithm consists in approximating the expectations function, h h , and solving for the associated optimal controls, x_t = x(s_t) x_t = x(s_t) . At step n n , with a current guess of the control, x(s_t) = \\varphi^n(s_t) x(s_t) = \\varphi^n(s_t) , and expectations function, h(s_t,x_t) = \\psi^n(s_t) h(s_t,x_t) = \\psi^n(s_t) : : - Compute the conditional expectation z_t = E_t[\\varphi^n(s_t)] z_t = E_t[\\varphi^n(s_t)] - Given the expectation, update the optimal control by solving 0 = \\left( f\\left(s_{t}, \\varphi^{n+1}(s), z_t \\right) \\right) 0 = \\left( f\\left(s_{t}, \\varphi^{n+1}(s), z_t \\right) \\right) - Given the optimal control, update the expectations function \\psi^{n+1}(s_t) = h(s_t, \\varphi^{n+1}(s_t)) \\psi^{n+1}(s_t) = h(s_t, \\varphi^{n+1}(s_t)) TODO: link to updated function.","title":"Parameterized Expectations"},{"location":"parameterized_expectations/#parameterized-expectations","text":"We consider an fgh model, that is a model with the form: s_t = g\\left(s_{t-1}, x_{t-1}, \\epsilon_t \\right) s_t = g\\left(s_{t-1}, x_{t-1}, \\epsilon_t \\right) 0 = f\\left(s_{t}, x_{t}, E_t[h(s_{t+1}, x_{t+1})] \\right) 0 = f\\left(s_{t}, x_{t}, E_t[h(s_{t+1}, x_{t+1})] \\right) where g g is the state transition function, f f is the arbitrage equation, and h h is the expectations function (more accurately, it is the function over which expectations are taken). The parameterized expectations algorithm consists in approximating the expectations function, h h , and solving for the associated optimal controls, x_t = x(s_t) x_t = x(s_t) . At step n n , with a current guess of the control, x(s_t) = \\varphi^n(s_t) x(s_t) = \\varphi^n(s_t) , and expectations function, h(s_t,x_t) = \\psi^n(s_t) h(s_t,x_t) = \\psi^n(s_t) : : - Compute the conditional expectation z_t = E_t[\\varphi^n(s_t)] z_t = E_t[\\varphi^n(s_t)] - Given the expectation, update the optimal control by solving 0 = \\left( f\\left(s_{t}, \\varphi^{n+1}(s), z_t \\right) \\right) 0 = \\left( f\\left(s_{t}, \\varphi^{n+1}(s), z_t \\right) \\right) - Given the optimal control, update the expectations function \\psi^{n+1}(s_t) = h(s_t, \\varphi^{n+1}(s_t)) \\psi^{n+1}(s_t) = h(s_t, \\varphi^{n+1}(s_t)) TODO: link to updated function.","title":"Parameterized expectations"},{"location":"perfect_foresight/","text":"Perfect foresight Consider a series for the exogenous process (m_t)_{0 \\leq t \\leq T} (m_t)_{0 \\leq t \\leq T} given exogenously. The perfect foresight problem consists in finding the path of optimal controls (x_t)_{0 \\leq t \\leq T} (x_t)_{0 \\leq t \\leq T} and corresponding states (s_t)_{0 \\leq t \\leq T} (s_t)_{0 \\leq t \\leq T} such that: \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) & \\\\ 0 & = & f\\left(m_{t}, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1}\\right) & \\ \\perp \\ \\underline{u} <= x_t <= \\overline{u} \\end{aligned} \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) & \\\\ 0 & = & f\\left(m_{t}, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1}\\right) & \\ \\perp \\ \\underline{u} <= x_t <= \\overline{u} \\end{aligned} Special conditions apply for the initial state and controls. Initial state ( {m_0}, {s_0}) {m_0}, {s_0}) is given exogenously. Final states and controls are determined by assuming the exogenous process satisfies m_t=m_T m_t=m_T for all t\\geq T t\\geq T and optimality conditions are satisfied in the last period: f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} \\leq x_T \\leq \\overline{u} f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} \\leq x_T \\leq \\overline{u} We assume that \\underline{u} \\underline{u} and \\overline{u} \\overline{u} are constants. This is not a big restriction since the model can always be reformulated in order to meet that constraint, by adding more equations. The stacked system of equations satisfied by the solution is: Transitions Arbitrage s_0 s_0 exogenous f(m_0, s_0, x_0, m_1, s_1, x_1) \\perp \\underline{u} <= x_0 <= \\overline{u} f(m_0, s_0, x_0, m_1, s_1, x_1) \\perp \\underline{u} <= x_0 <= \\overline{u} s_1 = g(m_0, s_0, x_0, m_1) s_1 = g(m_0, s_0, x_0, m_1) f(s_1, x_1, s_2, x_2) \\perp \\underline{u} <= x_1 <= \\overline{u} f(s_1, x_1, s_2, x_2) \\perp \\underline{u} <= x_1 <= \\overline{u} .... ... s_T = g(m_{T-1}, s_{T-1}, x_{T-1}, m_T) s_T = g(m_{T-1}, s_{T-1}, x_{T-1}, m_T) f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} <= x_T <= \\overline{u} f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} <= x_T <= \\overline{u} The system is solved using a nonlinear solver. function dolo.algos.perfect_foresight. deterministic_solve ( model , verbose=True , ignore_constraints=False , exogenous=None , s0=None , m0=None , T=100 , maxit=100 , initial_guess=None , solver='ncpsolve' , keep_steady_state=False , s1=None , shocks=None , tol=1e-06 ) Computes a perfect foresight simulation using a stacked-time algorithm. Typical simulation exercises are: - start from an out-of-equilibrium exogenous and/or endogenous state: specify s0 and or m0 . Missing values are taken from the calibration ( model.calibration ). - specify an exogenous path for shocks exogenous . Initial exogenous state m0 is then first value of exogenous values. Economy is supposed to have been at the equilibrium for t<0 t<0 , which pins down initial endogenous state s0 . x0 is a jump variable. If s0 s0 is not specified it is then set equal to the steady-state consistent with the first value The initial state is specified either by providing a series of exogenous shocks and assuming the model is initially in equilibrium with the first value of the shock, or by specifying an initial value for the states. Parameters model (Model) \u2014 Model to be solved verbose (boolean) \u2014 if True, the solver displays iterations ignore_constraints (bool) \u2014 if True, complementarity constraints are ignored. exogenous (array-like, dict, or pandas.DataFrame) \u2014 A specification for the path of exogenous variables (aka shocks). Can be any of the following (note by \"declaration order\" below we mean the order of model.symbols[\"exogenous\"] ): A 1d numpy array-like specifying a time series for a single exogenous variable, or all exogenous variables stacked into a single array. A 2d numpy array where each column specifies the time series for one of the shocks in declaration order. This must be an N by number of shocks 2d array. A dict where keys are strings found in model.symbols[\"exogenous\"] and values are a time series of values for that shock. For exogenous variables that do not appear in this dict, the shock is set to the calibrated value. Note that this interface is the most flexible as it allows the user to pass values for only a subset of the model shocks and it allows the passed time series to be of different lengths. A DataFrame where columns map shock names into time series. The same assumptions and behavior that are used in the dict case apply here If nothing is given here, exogenous is set equal to the calibrated values found in model.calibration[\"exogenous\"] for all periods. If the length of any time-series in shocks is less than T (see below) it is assumed that that particular shock will remain at the final given value for the duration of the simulation. s0 (None or ndarray or dict) \u2014 If vector with the value of initial states If an exogenous timeseries is given for exogenous shocks, s0 will be computed as the steady-state value that is consistent with its first value. T (int) \u2014 horizon for the perfect foresight simulation maxit (int) \u2014 maximum number of iteration for the nonlinear solver keep_steady_state (bool) \u2014 if True, initial steady-states and steady-controls are appended to the simulation with date -1. tol (float) \u2014 stopping criterium for the nonlinear solver Returns (pandas dataframe) a dataframe with T+1 observations of the model variables along the simulation (states, controls, auxiliaries). The simulation should return to a steady-state consistent with the last specified value of the exogenous shocks.","title":"Perfect Foresight"},{"location":"perfect_foresight/#perfect-foresight","text":"Consider a series for the exogenous process (m_t)_{0 \\leq t \\leq T} (m_t)_{0 \\leq t \\leq T} given exogenously. The perfect foresight problem consists in finding the path of optimal controls (x_t)_{0 \\leq t \\leq T} (x_t)_{0 \\leq t \\leq T} and corresponding states (s_t)_{0 \\leq t \\leq T} (s_t)_{0 \\leq t \\leq T} such that: \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) & \\\\ 0 & = & f\\left(m_{t}, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1}\\right) & \\ \\perp \\ \\underline{u} <= x_t <= \\overline{u} \\end{aligned} \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) & \\\\ 0 & = & f\\left(m_{t}, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1}\\right) & \\ \\perp \\ \\underline{u} <= x_t <= \\overline{u} \\end{aligned} Special conditions apply for the initial state and controls. Initial state ( {m_0}, {s_0}) {m_0}, {s_0}) is given exogenously. Final states and controls are determined by assuming the exogenous process satisfies m_t=m_T m_t=m_T for all t\\geq T t\\geq T and optimality conditions are satisfied in the last period: f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} \\leq x_T \\leq \\overline{u} f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} \\leq x_T \\leq \\overline{u} We assume that \\underline{u} \\underline{u} and \\overline{u} \\overline{u} are constants. This is not a big restriction since the model can always be reformulated in order to meet that constraint, by adding more equations. The stacked system of equations satisfied by the solution is: Transitions Arbitrage s_0 s_0 exogenous f(m_0, s_0, x_0, m_1, s_1, x_1) \\perp \\underline{u} <= x_0 <= \\overline{u} f(m_0, s_0, x_0, m_1, s_1, x_1) \\perp \\underline{u} <= x_0 <= \\overline{u} s_1 = g(m_0, s_0, x_0, m_1) s_1 = g(m_0, s_0, x_0, m_1) f(s_1, x_1, s_2, x_2) \\perp \\underline{u} <= x_1 <= \\overline{u} f(s_1, x_1, s_2, x_2) \\perp \\underline{u} <= x_1 <= \\overline{u} .... ... s_T = g(m_{T-1}, s_{T-1}, x_{T-1}, m_T) s_T = g(m_{T-1}, s_{T-1}, x_{T-1}, m_T) f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} <= x_T <= \\overline{u} f(m_T, s_T, x_T, m_T, s_T, x_T) \\perp \\underline{u} <= x_T <= \\overline{u} The system is solved using a nonlinear solver. function dolo.algos.perfect_foresight. deterministic_solve ( model , verbose=True , ignore_constraints=False , exogenous=None , s0=None , m0=None , T=100 , maxit=100 , initial_guess=None , solver='ncpsolve' , keep_steady_state=False , s1=None , shocks=None , tol=1e-06 ) Computes a perfect foresight simulation using a stacked-time algorithm. Typical simulation exercises are: - start from an out-of-equilibrium exogenous and/or endogenous state: specify s0 and or m0 . Missing values are taken from the calibration ( model.calibration ). - specify an exogenous path for shocks exogenous . Initial exogenous state m0 is then first value of exogenous values. Economy is supposed to have been at the equilibrium for t<0 t<0 , which pins down initial endogenous state s0 . x0 is a jump variable. If s0 s0 is not specified it is then set equal to the steady-state consistent with the first value The initial state is specified either by providing a series of exogenous shocks and assuming the model is initially in equilibrium with the first value of the shock, or by specifying an initial value for the states. Parameters model (Model) \u2014 Model to be solved verbose (boolean) \u2014 if True, the solver displays iterations ignore_constraints (bool) \u2014 if True, complementarity constraints are ignored. exogenous (array-like, dict, or pandas.DataFrame) \u2014 A specification for the path of exogenous variables (aka shocks). Can be any of the following (note by \"declaration order\" below we mean the order of model.symbols[\"exogenous\"] ): A 1d numpy array-like specifying a time series for a single exogenous variable, or all exogenous variables stacked into a single array. A 2d numpy array where each column specifies the time series for one of the shocks in declaration order. This must be an N by number of shocks 2d array. A dict where keys are strings found in model.symbols[\"exogenous\"] and values are a time series of values for that shock. For exogenous variables that do not appear in this dict, the shock is set to the calibrated value. Note that this interface is the most flexible as it allows the user to pass values for only a subset of the model shocks and it allows the passed time series to be of different lengths. A DataFrame where columns map shock names into time series. The same assumptions and behavior that are used in the dict case apply here If nothing is given here, exogenous is set equal to the calibrated values found in model.calibration[\"exogenous\"] for all periods. If the length of any time-series in shocks is less than T (see below) it is assumed that that particular shock will remain at the final given value for the duration of the simulation. s0 (None or ndarray or dict) \u2014 If vector with the value of initial states If an exogenous timeseries is given for exogenous shocks, s0 will be computed as the steady-state value that is consistent with its first value. T (int) \u2014 horizon for the perfect foresight simulation maxit (int) \u2014 maximum number of iteration for the nonlinear solver keep_steady_state (bool) \u2014 if True, initial steady-states and steady-controls are appended to the simulation with date -1. tol (float) \u2014 stopping criterium for the nonlinear solver Returns (pandas dataframe) a dataframe with T+1 observations of the model variables along the simulation (states, controls, auxiliaries). The simulation should return to a steady-state consistent with the last specified value of the exogenous shocks.","title":"Perfect foresight"},{"location":"perturbation/","text":"Perturbation function dolo.algos.perturbation. perturb ( model , details=True , verbose=True , steady_state=None , eigmax=0.999999 , solve_steady_state=False , order=1 ) Compute first order approximation of optimal controls Parameters model (Model) \u2014 NumericModel Model to be solved verbose (bool, optional) \u2014 boolean If True: displays number of contracting eigenvalues steady_state (optional) \u2014 ndarray Use supplied steady-state value to compute the approximation. The routine doesn't check whether it is really a solution or not. solve_steady_state (optional) \u2014 boolean Use nonlinear solver to find the steady-state orders \u2014 {1} Approximation order. (Currently, only first order is supported). Returns TaylorExpansion: Decision Rule for the optimal controls around the steady-state.","title":"Perturbation"},{"location":"perturbation/#perturbation","text":"function dolo.algos.perturbation. perturb ( model , details=True , verbose=True , steady_state=None , eigmax=0.999999 , solve_steady_state=False , order=1 ) Compute first order approximation of optimal controls Parameters model (Model) \u2014 NumericModel Model to be solved verbose (bool, optional) \u2014 boolean If True: displays number of contracting eigenvalues steady_state (optional) \u2014 ndarray Use supplied steady-state value to compute the approximation. The routine doesn't check whether it is really a solution or not. solve_steady_state (optional) \u2014 boolean Use nonlinear solver to find the steady-state orders \u2014 {1} Approximation order. (Currently, only first order is supported). Returns TaylorExpansion: Decision Rule for the optimal controls around the steady-state.","title":"Perturbation"},{"location":"processes/","text":"Shocks The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks aka distributions continuous auto-correlated process such as AR1 discrete processes such as discrete markov chains Exogenous shock processes are specified in the section exogenous of a yaml file. Here are some examples for each type of shock: Distributions / IIDProcess Univariate distributions IID Normal The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu IID LogNormal Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu Uniform Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max Beta If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1 Bernouilli Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3 Multivariate distributions Normal (multivariate) Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1] Mixtures For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. exogenous: !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3]) Continuous Autoregressive Process AR1 / VAR1 For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]] Markov chains Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]] Product We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof). Conditional processes Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Discretization methods for continous shocks To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Processes"},{"location":"processes/#shocks","text":"The type of exogenous shock associated to a model determines the kind of decision rule, which will be obtained by the solvers. Shocks can pertain to one of the following categories: continuous i.i.d. shocks aka distributions continuous auto-correlated process such as AR1 discrete processes such as discrete markov chains Exogenous shock processes are specified in the section exogenous of a yaml file. Here are some examples for each type of shock:","title":"Shocks"},{"location":"processes/#distributions-iidprocess","text":"","title":"Distributions / IIDProcess"},{"location":"processes/#univariate-distributions","text":"","title":"Univariate distributions"},{"location":"processes/#iid-normal","text":"The type of the shock is specified using yaml type annotations (starting with exclamation mark) Normal distribution with mean mu and variance \u03c3^2 has the probability density function f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) f(x; \\mu, \\sigma) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right) A normal shock in the yaml file with mean 0.2 and standard deviation 0.1 can be declared as follows !Normal: \u03c3: 0.1 \u03bc: 0.2 or !Normal: sigma: 0.1 mu: 0.2 Note Greek letter '\u03c3' or 'sigma' (similarly '\u03bc' or 'mu' ) are accepted. Note When defining shocks in a dolo model, that is in an exogenous section, The exogenous shock section can refer to parameters specified in the calibration section: symbols: ... parameters: [alpha, beta, mu, sigma] ... calibration: sigma: 0.01 mu: 0.0 exogenous: !Normal: \u03c3: sigma \u03bc: mu","title":"IID Normal"},{"location":"processes/#iid-lognormal","text":"Parametrization of a lognormal random variable Y is in terms of he mean, \u03bc, and standard deviation, \u03c3, of the unique normally distributed random variable X is as follows f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 f(x; \\mu, \\sigma) = \\frac{1}{x \\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{(\\log(x) - \\mu)^2}{2 \\sigma^2} \\right), \\quad x > 0 such that exp(X) = Y exogenous: !LogNormal: \u03c3: sigma \u03bc: mu","title":"IID LogNormal"},{"location":"processes/#uniform","text":"Uniform distribution over an interval [a,b] f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b f(x; a, b) = \\frac{1}{b - a}, \\quad a \\le x \\le b symbols: states: [k] controls: [c, d] exogenous: [e] parameters: [alpha, beta, mu, sigma, e_min, e_max] . . . exogenous: !Uniform: a: e_min b: e_max","title":"Uniform"},{"location":"processes/#beta","text":"If X\u223cGamma(\u03b1) and Y\u223cGamma(\u03b2) are distributed independently, then X/(X+Y)\u223cBeta(\u03b1,\u03b2). Beta distribution with shape parameters \u03b1 and \u03b2 has the following PDF f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] f(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha - 1} (1 x)^{\\beta - 1}, \\quad x \\in [0, 1] exogenous: !Beta \u03b1: 0.3 \u03b2: 0.1","title":"Beta"},{"location":"processes/#bernouilli","text":"Binomial distribution parameterized by p p yields 1 1 with probability p p and 0 0 with probability 1-p 1-p . !Bernouilli \u03c0: 0.3","title":"Bernouilli"},{"location":"processes/#multivariate-distributions","text":"","title":"Multivariate distributions"},{"location":"processes/#normal-multivariate","text":"Note the difference with UNormal . Parameters \u03a3 (not \u03c3 ) and \u03bc take a matrix and a vector respectively as argument. !Normal: \u03a3: [[0.0]] \u03bc: [0.1]","title":"Normal (multivariate)"},{"location":"processes/#mixtures","text":"For now, mixtures are defined for i.i.d. processes only. They take an integer valued distribution (like the Bernouilli one) and a different distribution associated to each of the values. exogenous: !Mixture index: !Bernouilli p: 0.3 distributions: 0: UNormal(\u03bc=0.0, \u03c3=0.01) 1: UNormal(\u03bc=0.0, \u03c3=0.02) Mixtures are not restricted to 1d distributions, but all distributions of the mixture must have the same dimension. Note Right now, mixtures accept only distributions as values. To switch between constants, one can use a Constant distribution as in the following examples. exogenous: e,v: !Mixture: index: !Bernouilli p: 0.3 distributions: 0: Constant(\u03bc=[0.1, 0.2]) 1: Constant(\u03bc=[0.2, 0.3])","title":"Mixtures"},{"location":"processes/#continuous-autoregressive-process","text":"","title":"Continuous Autoregressive Process"},{"location":"processes/#ar1-var1","text":"For now, AR1 is an alias for VAR1 . Autocorrelation \u03c1 must be a scalar (otherwise we don't know how to discretize). exogenous: !AR1 rho: 0.9 Sigma: [[\u03c3^2]]","title":"AR1 / VAR1"},{"location":"processes/#markov-chains","text":"Markov chains are constructed by providing a list of nodes and a transition matrix. exogenous: !MarkovChain values: [[-0.01, 0.1],[0.01, 0.1]] transitions: [[0.9, 0.1], [0.1, 0.9]]","title":"Markov chains"},{"location":"processes/#product","text":"We can also specify more than one process. For instance if we want to combine a VAR1 and an Normal Process we use the tag Product and write: exogenous: !Product - !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] - !Normal: \u03c3: sigma \u03bc: mu Note Note that another syntax is accepted, in the specific context of a dolo exogenous section. It keeps the Product operator implicit. Suppose a dolo model has r,w,e r,w,e as exogenous shocks. It is possible to list several shocks for each variable as in the following example: symbols: ... exogenous: [r,w,e] exogenous: r,w: !VAR1 rho: 0.75 Sigma: [[0.015^2, -0.05], [-0.05, 0.012]] e !Normal: \u03c3: sigma \u03bc: mu In this case we define several shocks for several variables (or combinations thereof).","title":"Product"},{"location":"processes/#conditional-processes","text":"Support is very limited for now. It is possible to define markov chains, whose transitions (not the values) depend on the output of another process. exogenous: !Conditional condition: !UNormal mu: 0.0 sigma: 0.2 type: Markov arguments: !Function arguments: [x] value: states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]] Note The plan is to replace the clean and explicit but somewhat tedious syntax above by the following (where dependence is detected automatically): exogenous: x: !UNormal mu: 0.0 sigma: 0.2 y: !Markov states: [0.1, 0.2] transitions: !Matrix [[1-0.1-x, 0.1+x], [0.5, 0.5]]","title":"Conditional processes"},{"location":"processes/#discretization-methods-for-continous-shocks","text":"To solve a non-linear model with a given exogenous process, one can apply different types of procedures to discretize the continous process: Type Distribution Discretization procedure Univariate iid UNormal(\u03bc, \u03c3) Equiprobable, Gauss-Hermite Nodes Univariate iid LogNormal(\u03bc, \u03c3) Equiprobable Univariate iid Uniform(a, b ) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable Univariate iid Beta(\u03b1, \u03b2) Equiprobable VAR1 Generalized Discretization Method (GDP), Markov Chain Note Here we can define shortly each method. Then perhaps link to a jupyter notebook as discussed: Conditional on the discretization approach, present the results of the corresponding method solutions and simulations. Discuss further discretization methods and related dolo objects.","title":"Discretization methods for continous shocks"},{"location":"simulation/","text":"Simulation function dolo.algos.simulations. simulate ( model , dr , process=None , N=1 , T=40 , s0=None , i0=None , m0=None , driving_process=None , seed=42 , stochastic=True ) Simulate a model using the specified decision rule. Returns (xarray.DataArray:) returns a T x N x n_v array where n_v is the number of variables.","title":"Simulation"},{"location":"simulation/#simulation","text":"function dolo.algos.simulations. simulate ( model , dr , process=None , N=1 , T=40 , s0=None , i0=None , m0=None , driving_process=None , seed=42 , stochastic=True ) Simulate a model using the specified decision rule. Returns (xarray.DataArray:) returns a T x N x n_v array where n_v is the number of variables.","title":"Simulation"},{"location":"steady_state/","text":"Steady-state The deterministic state of a model corresponds to steady-state values \\overline{m} \\overline{m} of the exogenous process. States and controls satisfy: \\overline{s} = g\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m} \\right) \\overline{s} = g\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m} \\right) 0 = \\left[ f\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m}, \\overline{s}, \\overline{x} \\right) \\right] 0 = \\left[ f\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m}, \\overline{s}, \\overline{x} \\right) \\right] where g g is the state transition function, and f f is the arbitrage equation. Note that the shocks, \\epsilon \\epsilon , are held at their deterministic mean. The steady state function consists in solving the system of arbitrage equations for the steady state values of the controls, \\overline{x} \\overline{x} , which can then be used along with the transition function to find the steady state values of the state variables, \\overline{s} \\overline{s} . function dolo.algos.steady_state. residuals ( model , calib=None )","title":"Steady-State"},{"location":"steady_state/#steady-state","text":"The deterministic state of a model corresponds to steady-state values \\overline{m} \\overline{m} of the exogenous process. States and controls satisfy: \\overline{s} = g\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m} \\right) \\overline{s} = g\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m} \\right) 0 = \\left[ f\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m}, \\overline{s}, \\overline{x} \\right) \\right] 0 = \\left[ f\\left(\\overline{m}, \\overline{s}, \\overline{x}, \\overline{m}, \\overline{s}, \\overline{x} \\right) \\right] where g g is the state transition function, and f f is the arbitrage equation. Note that the shocks, \\epsilon \\epsilon , are held at their deterministic mean. The steady state function consists in solving the system of arbitrage equations for the steady state values of the controls, \\overline{x} \\overline{x} , which can then be used along with the transition function to find the steady state values of the state variables, \\overline{s} \\overline{s} . function dolo.algos.steady_state. residuals ( model , calib=None )","title":"Steady-state"},{"location":"time_iteration/","text":"Time iteration We consider a model with the form: \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) \\\\ 0 & = & E_t \\left[ f\\left(m_t, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1} \\right) \\right] \\end{aligned} \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) \\\\ 0 & = & E_t \\left[ f\\left(m_t, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1} \\right) \\right] \\end{aligned} where g g is the state transition function, and f f is the arbitrage equation. The time iteration algorithm consists in approximating the optimal controls as a function \\varphi \\varphi of exogenous and endogenous controls x_t = \\varphi(m_t,s_t) x_t = \\varphi(m_t,s_t) . At step n n , the current guess for the control, x(s_t) = \\varphi^n(m_t, s_t) x(s_t) = \\varphi^n(m_t, s_t) , serves as the control being exercised next period : Taking \\varphi^n \\varphi^n as the initial guess, find the current period's controls \\varphi^{n+1}(m_t,s_t) \\varphi^{n+1}(m_t,s_t) for any (m_t,s_t) (m_t,s_t) by solving the arbitrage equation : 0 = E_t \\left[ f\\left(m_t, s_{t}, \\varphi^{n+1}(m_t, s_t), g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1}), \\varphi^{n}(m_{t+1},g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1})) \\right) \\right] 0 = E_t \\left[ f\\left(m_t, s_{t}, \\varphi^{n+1}(m_t, s_t), g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1}), \\varphi^{n}(m_{t+1},g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1})) \\right) \\right] Repeat until \\eta_{n+1} = \\max_{m,s}\\left |\\varphi^{n+1}(m,s) - \\varphi^{n}(m,s) \\right| \\eta_{n+1} = \\max_{m,s}\\left |\\varphi^{n+1}(m,s) - \\varphi^{n}(m,s) \\right| is smaller than prespecified criterium \\tau_{\u03b7} \\tau_{\u03b7} function dolo.algos.time_iteration. time_iteration ( model , dr0=None , verbose=True , details=True , ignore_constraints=False , trace=False , dprocess=None , maxit=1000 , inner_maxit=10 , tol=1e-06 , hook=None , interp_method='cubic' , with_complementarities=None ) Finds a global solution for model using backward time-iteration. This algorithm iterates on the residuals of the arbitrage equations Parameters model (Model) \u2014 model to be solved dr0 (decision rule) \u2014 initial guess for the decision rule verbose (bool) \u2014 if True, display iterations hook (Callable) \u2014 function to be called within each iteration, useful for debugging purposes with_complementarities (bool (True)) \u2014 if False, complementarity conditions are ignored Returns (decision rule :) approximated solution dataclass dolo.algos.results. TimeIterationResult ( dr , iterations , complementarities , dprocess , x_converged , x_tol , err , log , trace ) Bases dolo.algos.results.AlgoResult TimeIterationResult(dr: object, iterations: int, complementarities: bool, dprocess: object, x_converged: bool, x_tol: float, err: float, log: object, trace: object)","title":"Time Iteration"},{"location":"time_iteration/#time-iteration","text":"We consider a model with the form: \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) \\\\ 0 & = & E_t \\left[ f\\left(m_t, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1} \\right) \\right] \\end{aligned} \\begin{aligned} s_t & = & g\\left(m_{t-1}, s_{t-1}, x_{t-1}, m_t \\right) \\\\ 0 & = & E_t \\left[ f\\left(m_t, s_{t}, x_{t}, m_{t+1}, s_{t+1}, x_{t+1} \\right) \\right] \\end{aligned} where g g is the state transition function, and f f is the arbitrage equation. The time iteration algorithm consists in approximating the optimal controls as a function \\varphi \\varphi of exogenous and endogenous controls x_t = \\varphi(m_t,s_t) x_t = \\varphi(m_t,s_t) . At step n n , the current guess for the control, x(s_t) = \\varphi^n(m_t, s_t) x(s_t) = \\varphi^n(m_t, s_t) , serves as the control being exercised next period : Taking \\varphi^n \\varphi^n as the initial guess, find the current period's controls \\varphi^{n+1}(m_t,s_t) \\varphi^{n+1}(m_t,s_t) for any (m_t,s_t) (m_t,s_t) by solving the arbitrage equation : 0 = E_t \\left[ f\\left(m_t, s_{t}, \\varphi^{n+1}(m_t, s_t), g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1}), \\varphi^{n}(m_{t+1},g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1})) \\right) \\right] 0 = E_t \\left[ f\\left(m_t, s_{t}, \\varphi^{n+1}(m_t, s_t), g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1}), \\varphi^{n}(m_{t+1},g(m_t, s_t, \\varphi^{n+1}(m_t, s_t), m_{t+1})) \\right) \\right] Repeat until \\eta_{n+1} = \\max_{m,s}\\left |\\varphi^{n+1}(m,s) - \\varphi^{n}(m,s) \\right| \\eta_{n+1} = \\max_{m,s}\\left |\\varphi^{n+1}(m,s) - \\varphi^{n}(m,s) \\right| is smaller than prespecified criterium \\tau_{\u03b7} \\tau_{\u03b7} function dolo.algos.time_iteration. time_iteration ( model , dr0=None , verbose=True , details=True , ignore_constraints=False , trace=False , dprocess=None , maxit=1000 , inner_maxit=10 , tol=1e-06 , hook=None , interp_method='cubic' , with_complementarities=None ) Finds a global solution for model using backward time-iteration. This algorithm iterates on the residuals of the arbitrage equations Parameters model (Model) \u2014 model to be solved dr0 (decision rule) \u2014 initial guess for the decision rule verbose (bool) \u2014 if True, display iterations hook (Callable) \u2014 function to be called within each iteration, useful for debugging purposes with_complementarities (bool (True)) \u2014 if False, complementarity conditions are ignored Returns (decision rule :) approximated solution dataclass dolo.algos.results. TimeIterationResult ( dr , iterations , complementarities , dprocess , x_converged , x_tol , err , log , trace ) Bases dolo.algos.results.AlgoResult TimeIterationResult(dr: object, iterations: int, complementarities: bool, dprocess: object, x_converged: bool, x_tol: float, err: float, log: object, trace: object)","title":"Time iteration"},{"location":"value_iteration/","text":"Value function iteration function dolo.algos.value_iteration. evaluate_policy ( model , mdr , tol=1e-08 , maxit=2000 , grid={} , verbose=True , dr0=None , hook=None , integration_orders=None , details=False , interp_method='cubic' ) Compute value function corresponding to policy dr Parameters model \u2014 \"dtcscc\" model. Must contain a 'value' function. mdr \u2014 decision rule to evaluate Returns decision rule: value function (a function of the space similar to a decision rule object) function dolo.algos.value_iteration. value_iteration ( model , verbose=False , details=True , tol=1e-06 , maxit=500 , maxit_howard=20 ) Solve for the value function and associated Markov decision rule by iterating over the value function. Parameters model (Model) \u2014 model to be solved dr \u2014 decision rule to evaluate Returns (ValueIterationResult) mdr : Markov decision rule The solved decision rule/policy function mdrv: decision rule The solved value function dataclass dolo.algos.results. ValueIterationResult ( dr , drv , iterations , dprocess , x_converged , x_tol , x_err , v_converged , v_tol , v_err , log , trace ) Bases dolo.algos.results.AlgoResult ValueIterationResult(dr: object, drv: object, iterations: int, dprocess: object, x_converged: object, x_tol: float, x_err: float, v_converged: bool, v_tol: float, v_err: float, log: object, trace: object)","title":"Value Iteration"},{"location":"value_iteration/#value-function-iteration","text":"function dolo.algos.value_iteration. evaluate_policy ( model , mdr , tol=1e-08 , maxit=2000 , grid={} , verbose=True , dr0=None , hook=None , integration_orders=None , details=False , interp_method='cubic' ) Compute value function corresponding to policy dr Parameters model \u2014 \"dtcscc\" model. Must contain a 'value' function. mdr \u2014 decision rule to evaluate Returns decision rule: value function (a function of the space similar to a decision rule object) function dolo.algos.value_iteration. value_iteration ( model , verbose=False , details=True , tol=1e-06 , maxit=500 , maxit_howard=20 ) Solve for the value function and associated Markov decision rule by iterating over the value function. Parameters model (Model) \u2014 model to be solved dr \u2014 decision rule to evaluate Returns (ValueIterationResult) mdr : Markov decision rule The solved decision rule/policy function mdrv: decision rule The solved value function dataclass dolo.algos.results. ValueIterationResult ( dr , drv , iterations , dprocess , x_converged , x_tol , x_err , v_converged , v_tol , v_err , log , trace ) Bases dolo.algos.results.AlgoResult ValueIterationResult(dr: object, drv: object, iterations: int, dprocess: object, x_converged: object, x_tol: float, x_err: float, v_converged: bool, v_tol: float, v_err: float, log: object, trace: object)","title":"Value function iteration"}]}